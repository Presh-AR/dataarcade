<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Recovery Runner - AutoRABIT Vault</title>
    <meta name="description" content="Run through data disasters and learn how AutoRABIT Vault protects your Salesforce data!">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* ==========================================
           ROOT VARIABLES & RESET
           ========================================== */
        :root {
            --primary: #FFFFFF;
            --primary-dark: #CCCCCC;
            --secondary: #888888;
            --accent: #FFFFFF;
            --danger: #FF4444;
            --warning: #FFAA00;
            --success: #00FF88;
            --bg-dark: #000000;
            --bg-medium: #000000;
            --bg-gradient: #000000;
            --text-light: #FFFFFF;
            --text-muted: #AAAAAA;
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --neon-glow: 0 0 10px rgba(255, 255, 255, 0.3);
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Rajdhani', sans-serif;
            --font-mono: 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-light);
        }

        h1, h2, h3, h4, .game-title, .score-value {
            font-family: var(--font-display);
        }

        /* ==========================================
           ANIMATIONS
           ========================================== */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); }
            92% { transform: translate(-2px, 2px); }
            94% { transform: translate(2px, -2px); }
            96% { transform: translate(-2px, -2px); }
            98% { transform: translate(2px, 2px); }
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes shieldPulse {
            0%, 100% { box-shadow: 0 0 20px var(--primary), inset 0 0 20px rgba(0, 212, 170, 0.3); }
            50% { box-shadow: 0 0 40px var(--primary), inset 0 0 40px rgba(0, 212, 170, 0.5); }
        }

        /* ==========================================
           GAME CONTAINER & CANVAS
           ========================================== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000000;
        }

        #game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes nebula {
            0% { opacity: 0.8; }
            100% { opacity: 1; transform: scale(1.05); }
        }

        #gameCanvas {
            display: block;
            background: transparent;
            max-width: 100%;
            max-height: 100%;
            border-radius: 12px;
            border: 2px solid var(--glass-border);
            box-shadow: var(--neon-glow), inset 0 0 60px rgba(108, 92, 231, 0.1);
        }

        /* ==========================================
           MODAL OVERLAY
           ========================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000000;
            pointer-events: none;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: #000000;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 24px;
            padding: 40px;
            max-width: 520px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.8);
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #FFFFFF;
            border-radius: 24px 24px 0 0;
        }

        /* ==========================================
           LOGO & BRANDING
           ========================================== */
        .logo-container {
            text-align: center;
            margin-bottom: 35px;
        }

        .logo-icon {
            width: 90px;
            height: 90px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            animation: iconFloat 4s ease-in-out infinite, iconGlow 2s ease-in-out infinite alternate;
            box-shadow: 0 15px 50px rgba(0, 255, 209, 0.4), inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        @keyframes iconFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(3deg); }
        }

        @keyframes iconGlow {
            0% { box-shadow: 0 15px 50px rgba(0, 255, 209, 0.4), inset 0 -5px 20px rgba(0, 0, 0, 0.3); }
            100% { box-shadow: 0 20px 60px rgba(0, 255, 209, 0.6), inset 0 -5px 20px rgba(0, 0, 0, 0.3), 0 0 30px rgba(108, 92, 231, 0.3); }
        }

        .game-title {
            font-size: 2.2rem;
            font-weight: 900;
            color: #FFFFFF;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            letter-spacing: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }

        /* ==========================================
           FORM STYLES
           ========================================== */
        .form-group {
            margin-bottom: 22px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 700;
            color: var(--primary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 16px 20px;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid rgba(0, 255, 209, 0.2);
            border-radius: 14px;
            color: var(--text-light);
            font-size: 1rem;
            font-family: var(--font-body);
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 255, 209, 0.25), inset 0 0 20px rgba(0, 255, 209, 0.05);
            background: rgba(108, 92, 231, 0.15);
        }

        .form-group input::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }

        .form-group select option {
            background: var(--bg-dark);
            color: var(--text-light);
            padding: 10px;
        }

        .form-error {
            color: var(--danger);
            font-size: 0.8rem;
            margin-top: 8px;
            display: none;
            font-weight: 600;
        }

        .form-error.show {
            display: block;
            animation: shakeError 0.4s ease-out;
        }

        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* ==========================================
           BUTTONS
           ========================================== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 18px 36px;
            border: none;
            border-radius: 14px;
            font-size: 1rem;
            font-weight: 700;
            font-family: var(--font-display);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--bg-dark);
            box-shadow: 0 10px 40px rgba(0, 255, 209, 0.4), inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .btn-primary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 50px rgba(0, 255, 209, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .btn-primary:active {
            transform: translateY(-1px) scale(0.99);
        }

        .btn-secondary {
            background: rgba(108, 92, 231, 0.2);
            border: 2px solid var(--glass-border);
            color: var(--text-light);
        }

        .btn-secondary:hover {
            background: rgba(108, 92, 231, 0.3);
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 255, 209, 0.2);
        }

        .btn-cta {
            background: linear-gradient(135deg, var(--accent) 0%, #E84393 100%);
            color: white;
            box-shadow: 0 10px 40px rgba(253, 121, 168, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .btn-cta:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 50px rgba(253, 121, 168, 0.5);
        }

        .btn-social {
            padding: 14px 22px;
            font-size: 0.8rem;
            flex: 1;
            letter-spacing: 1px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-full {
            width: 100%;
        }

        /* ==========================================
           START SCREEN
           ========================================== */
        .start-screen {
            text-align: center;
        }

        .welcome-text {
            font-size: 1.5rem;
            margin-bottom: 10px;
            animation: slideIn 0.5s ease-out;
        }

        .industry-intro {
            color: var(--text-muted);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .industry-intro strong {
            color: var(--primary);
        }

        .game-instructions {
            background: var(--glass);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: left;
        }

        .game-instructions h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .game-instructions ul {
            list-style: none;
            padding: 0;
        }

        .game-instructions li {
            padding: 8px 0;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-instructions li::before {
            content: '‚ñ∏';
            color: var(--primary);
        }

        .high-score-display {
            background: linear-gradient(135deg, rgba(0, 212, 170, 0.1) 0%, rgba(0, 212, 170, 0.05) 100%);
            border: 1px solid rgba(0, 212, 170, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .high-score-display span {
            color: var(--primary);
            font-size: 1.5rem;
            font-weight: 800;
        }

        /* ==========================================
           DIFFICULTY SELECTOR
           ========================================== */
        .difficulty-section {
            margin-bottom: 25px;
        }

        .difficulty-section h3 {
            color: var(--primary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 15px;
            font-family: var(--font-display);
        }

        .difficulty-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .difficulty-option {
            position: relative;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid rgba(0, 255, 209, 0.2);
            border-radius: 14px;
            padding: 16px 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }

        .difficulty-option:hover {
            border-color: var(--primary);
            background: rgba(108, 92, 231, 0.15);
            transform: translateY(-2px);
        }

        .difficulty-option.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.15) 0%, rgba(108, 92, 231, 0.15) 100%);
            box-shadow: 0 0 25px rgba(0, 255, 209, 0.2), inset 0 0 20px rgba(0, 255, 209, 0.05);
        }

        .difficulty-option.selected::before {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 10px;
            color: var(--primary);
            font-weight: bold;
            font-size: 0.9rem;
        }

        .difficulty-icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
            display: block;
        }

        .difficulty-name {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .difficulty-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .difficulty-multiplier {
            display: inline-block;
            margin-top: 8px;
            padding: 3px 10px;
            background: rgba(0, 255, 209, 0.15);
            border-radius: 20px;
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--primary);
            font-family: var(--font-display);
            letter-spacing: 0.5px;
        }

        .difficulty-option.selected .difficulty-multiplier {
            background: var(--primary);
            color: var(--bg-dark);
        }

        /* Speed indicator badge */
        .speed-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-top: 5px;
        }

        .speed-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
            opacity: 0.3;
        }

        .speed-dot.active {
            background: var(--primary);
            opacity: 1;
            box-shadow: 0 0 6px var(--primary);
        }

        /* Current difficulty display in HUD */
        .hud-difficulty {
            font-size: 0.75rem;
            padding: 8px 14px;
            background: rgba(108, 92, 231, 0.2);
            border-radius: 8px;
            margin-top: 8px;
        }

        .hud-difficulty span {
            color: var(--warning);
            font-weight: 700;
        }

        @media (max-width: 480px) {
            .difficulty-options {
                grid-template-columns: 1fr;
            }
            
            .difficulty-option {
                padding: 14px 12px;
            }

            .difficulty-icon {
                font-size: 1.5rem;
            }
        }

        /* ==========================================
           END SCREEN
           ========================================== */
        .end-screen {
            text-align: center;
        }

        .score-display {
            margin: 35px 0;
            position: relative;
        }

        .score-display::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(0, 255, 209, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: scorePulse 2s ease-in-out infinite;
        }

        @keyframes scorePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }

        .score-value {
            font-size: 5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            text-shadow: 0 0 60px rgba(0, 255, 209, 0.5);
            animation: scoreReveal 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes scoreReveal {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .score-label {
            color: var(--text-muted);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 600;
        }

        .badge-earned {
            background: linear-gradient(135deg, var(--warning) 0%, var(--accent) 100%);
            border-radius: 16px;
            padding: 20px;
            margin: 25px 0;
            animation: badgeReveal 0.6s cubic-bezier(0.16, 1, 0.3, 1), badgeShine 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        @keyframes badgeReveal {
            from { transform: scale(0) rotate(-10deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes badgeShine {
            0%, 100% { box-shadow: 0 5px 30px rgba(253, 203, 110, 0.4); }
            50% { box-shadow: 0 10px 50px rgba(253, 203, 110, 0.6), 0 0 20px rgba(253, 121, 168, 0.3); }
        }

        .badge-earned::before {
            content: '‚òÖ';
            position: absolute;
            font-size: 80px;
            right: -10px;
            top: -20px;
            opacity: 0.2;
        }

        .badge-earned.hidden {
            display: none;
        }

        .badge-earned h4 {
            color: var(--bg-dark);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .badge-earned p {
            color: rgba(0, 0, 0, 0.7);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .vault-tip {
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.1) 0%, rgba(108, 92, 231, 0.1) 100%);
            border-left: 4px solid var(--primary);
            padding: 18px 20px;
            margin: 25px 0;
            text-align: left;
            border-radius: 0 14px 14px 0;
            position: relative;
        }

        .vault-tip::before {
            content: 'üí°';
            position: absolute;
            left: -18px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            background: var(--bg-medium);
            padding: 5px;
            border-radius: 50%;
        }

        .vault-tip strong {
            color: var(--primary);
            font-weight: 700;
        }

        .share-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(108, 92, 231, 0.1);
            border-radius: 16px;
            border: 1px solid rgba(0, 255, 209, 0.1);
        }

        .share-section h4 {
            color: var(--text-light);
            margin-bottom: 18px;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .share-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-x { 
            background: linear-gradient(135deg, #14171A 0%, #000 100%); 
            color: #fff;
            border: 1px solid #333;
        }
        .btn-linkedin { 
            background: linear-gradient(135deg, #0A66C2 0%, #004182 100%); 
            color: #fff; 
        }
        .btn-email { 
            background: linear-gradient(135deg, var(--secondary) 0%, #5B4CC4 100%); 
            color: #fff; 
        }
        .btn-friend {
            background: linear-gradient(135deg, var(--accent) 0%, #E84393 100%);
            color: #fff;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 25px;
        }

        /* Friend Email Modal */
        .friend-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 2, 33, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .friend-modal.hidden {
            display: none;
        }

        .friend-modal-content {
            background: var(--bg-medium);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .friend-modal-content h3 {
            color: var(--primary);
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .friend-modal-content input {
            width: 100%;
            padding: 14px 18px;
            margin-bottom: 15px;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-light);
            font-family: var(--font-body);
            font-size: 1rem;
        }

        .friend-modal-content input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .friend-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .friend-modal-buttons .btn {
            flex: 1;
            padding: 12px;
            font-size: 0.85rem;
        }

        /* ==========================================
           HUD (Heads Up Display)
           ========================================== */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }

        .hud-item {
            background: rgba(13, 2, 33, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid var(--glass-border);
            border-radius: 14px;
            padding: 14px 22px;
            pointer-events: auto;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.4);
        }

        .hud-score {
            font-size: 1.3rem;
            font-weight: 700;
            font-family: var(--font-display);
            letter-spacing: 1px;
        }

        .hud-score span {
            color: var(--primary);
            text-shadow: 0 0 20px rgba(0, 255, 209, 0.5);
        }

        .hud-controls {
            display: flex;
            gap: 10px;
        }

        .hud-btn {
            background: rgba(108, 92, 231, 0.3);
            border: 2px solid var(--glass-border);
            border-radius: 10px;
            padding: 10px 15px;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-family: var(--font-body);
            font-weight: 600;
        }

        .hud-btn:hover {
            background: rgba(0, 255, 209, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 255, 209, 0.3);
        }

        .power-up-indicator {
            position: absolute;
            top: 85px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--bg-dark);
            padding: 12px 30px;
            border-radius: 30px;
            font-weight: 900;
            font-family: var(--font-display);
            letter-spacing: 2px;
            animation: shieldActive 0.5s ease-in-out infinite alternate;
            z-index: 100;
            box-shadow: var(--neon-glow);
            border: 2px solid rgba(255,255,255,0.3);
        }

        @keyframes shieldActive {
            0% { transform: translateX(-50%) scale(1); box-shadow: var(--neon-glow); }
            100% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 40px rgba(0, 255, 209, 0.7), 0 0 80px rgba(0, 255, 209, 0.4); }
        }

        .power-up-indicator.hidden {
            display: none;
        }

        /* ==========================================
           PAUSE OVERLAY
           ========================================== */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .pause-overlay.hidden {
            display: none;
        }

        .pause-content {
            text-align: center;
        }

        .pause-content h2 {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 20px;
        }

        /* ==========================================
           MOBILE CONTROLS
           ========================================== */
        .mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: none;
            justify-content: center;
            gap: 25px;
            z-index: 100;
        }

        .mobile-btn {
            width: 85px;
            height: 85px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.2) 0%, rgba(108, 92, 231, 0.2) 100%);
            border: 3px solid var(--primary);
            color: var(--primary);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 0 30px rgba(0, 255, 209, 0.3), inset 0 0 30px rgba(0, 255, 209, 0.1);
            transition: all 0.2s ease;
        }

        .mobile-btn:active {
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.5) 0%, rgba(108, 92, 231, 0.5) 100%);
            transform: scale(0.92);
            box-shadow: 0 0 50px rgba(0, 255, 209, 0.5), inset 0 0 50px rgba(0, 255, 209, 0.2);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }

        /* Wave Warning Banner */
        .wave-banner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.3), transparent);
            padding: 8px;
            text-align: center;
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--danger);
            letter-spacing: 2px;
            animation: waveBanner 0.3s ease-in-out infinite alternate;
            z-index: 50;
        }

        @keyframes waveBanner {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .wave-banner.hidden {
            display: none;
        }

        /* ==========================================
           RESPONSIVE
           ========================================== */
        @media (max-width: 600px) {
            .modal {
                padding: 25px;
                margin: 10px;
            }

            .game-title {
                font-size: 1.6rem;
            }

            .score-value {
                font-size: 3rem;
            }

            .btn {
                padding: 14px 24px;
                font-size: 0.9rem;
            }

            .share-buttons {
                flex-direction: column;
            }

            .btn-social {
                width: 100%;
            }

            .hud {
                flex-direction: column;
                gap: 10px;
            }
        }

        /* ==========================================
           ACCESSIBILITY
           ========================================== */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        *:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
    </style>
</head>
<body>
    <!-- Registration Modal -->
    <div id="registration-modal" class="modal-overlay" role="dialog" aria-labelledby="reg-title" aria-modal="true">
        <div class="modal">
            <div class="logo-container">
                <div class="logo-icon" aria-hidden="true">üõ°Ô∏è</div>
                <h1 id="reg-title" class="game-title">Recovery Runner</h1>
                <p class="game-subtitle">Powered by AutoRABIT Vault</p>
            </div>
            
            <form id="registration-form" novalidate>
                <div class="form-group">
                    <label for="player-name">Your Name</label>
                    <input type="text" id="player-name" name="name" placeholder="Enter your name" required aria-required="true">
                    <p class="form-error" id="name-error">Please enter your name</p>
                </div>
                
                <div class="form-group">
                    <label for="player-email">Email Address</label>
                    <input type="email" id="player-email" name="email" placeholder="you@company.com" required aria-required="true">
                    <p class="form-error" id="email-error">Please enter a valid email address</p>
                </div>
                
                <div class="form-group">
                    <label for="player-industry">Your Industry</label>
                    <select id="player-industry" name="industry" aria-label="Select your industry">
                        <option value="">Select your industry...</option>
                        <option value="banking">Banking & Financial Services</option>
                        <option value="healthcare">Healthcare & Life Sciences</option>
                        <option value="retail">Retail & Consumer Goods</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                
                <button type="submit" class="btn btn-primary btn-full">
                    üöÄ Enter the Data Zone
                </button>
            </form>
        </div>
    </div>

    <!-- Start Screen Modal -->
    <div id="start-modal" class="modal-overlay hidden" role="dialog" aria-labelledby="start-title" aria-modal="true">
        <div class="modal start-screen">
            <div class="logo-container">
                <div class="logo-icon" aria-hidden="true">üèÉ</div>
                <h1 id="start-title" class="game-title">Ready to Run?</h1>
            </div>
            
            <p class="welcome-text" id="welcome-text">Welcome, Player!</p>
            <p class="industry-intro" id="industry-intro" style="font-size: 1.1rem; line-height: 1.6; margin: 20px 0;">
                <strong>Your Mission:</strong> Jump over data disasters that threaten your business. Each hazard represents a real risk that can cost your company thousands in fines, lost revenue, and reputation damage. Learn what these threats mean for your business as you play!
            </p>
            <p style="color: var(--text-muted); font-size: 0.95rem; margin-top: 15px;">
                üí° <strong>Tip:</strong> As hazards approach, you'll see what they mean for your business. Jump over them to survive!
            </p>
            
            <div class="high-score-display" id="high-score-section">
                <p>üèÜ Your Best Score: <span id="high-score-value">0</span></p>
            </div>

            <!-- Difficulty Selector -->
            <div class="difficulty-section">
                <h3>‚ö° Select Difficulty</h3>
                <div class="difficulty-options" id="difficulty-options">
                    <div class="difficulty-option" data-difficulty="easy">
                        <span class="difficulty-icon">üê¢</span>
                        <div class="difficulty-name">Easy</div>
                        <div class="difficulty-desc">Relaxed pace - Perfect for reading data challenges</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">0.5√ó Score</span>
                    </div>
                    <div class="difficulty-option selected" data-difficulty="normal">
                        <span class="difficulty-icon">üèÉ</span>
                        <div class="difficulty-name">Normal</div>
                        <div class="difficulty-desc">Balanced challenge for most players</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">1√ó Score</span>
                    </div>
                    <div class="difficulty-option" data-difficulty="hard">
                        <span class="difficulty-icon">üî•</span>
                        <div class="difficulty-name">Hard</div>
                        <div class="difficulty-desc">Fast & intense - For experienced players</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">1.5√ó Score</span>
                    </div>
                    <div class="difficulty-option" data-difficulty="extreme">
                        <span class="difficulty-icon">üíÄ</span>
                        <div class="difficulty-name">Extreme</div>
                        <div class="difficulty-desc">Ultimate challenge - Only the brave survive!</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                        </div>
                        <span class="difficulty-multiplier">2√ó Score</span>
                    </div>
                </div>
            </div>

            <!-- Game Mode Selector -->
            <div class="mode-section" style="margin: 25px 0;">
                <h3 style="margin-bottom: 15px;">üéØ Game Mode</h3>
                <div class="mode-toggle" id="mode-toggle" style="display: flex; gap: 12px;">
                    <button class="mode-btn selected" data-mode="arcade" id="arcade-mode-btn" style="flex: 1; padding: 16px; background: rgba(108, 92, 231, 0.2); border: 2px solid var(--primary); border-radius: 12px; color: white; font-family: var(--font-body); font-size: 0.95rem; cursor: pointer; transition: all 0.3s;">
                        <span style="font-size: 1.5rem; display: block; margin-bottom: 5px;">üéÆ</span>
                        <strong>Arcade Mode</strong>
                        <span style="display: block; font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;">Classic gameplay with visual previews</span>
                    </button>
                    <button class="mode-btn" data-mode="learning" id="learning-mode-btn" style="flex: 1; padding: 16px; background: rgba(100, 200, 255, 0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-family: var(--font-body); font-size: 0.95rem; cursor: pointer; transition: all 0.3s;">
                        <span style="font-size: 1.5rem; display: block; margin-bottom: 5px;">üìö</span>
                        <strong>Learning Mode</strong>
                        <span style="display: block; font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;">Slower pace with Vault education</span>
                    </button>
                </div>
                <p id="mode-description" style="font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; text-align: center;">
                    üéÆ <strong>Arcade:</strong> Fast-paced action with hazard previews at the top of the screen
                </p>
            </div>
            
            <div class="game-instructions">
                <h3>üéØ How to Play</h3>
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    Each hazard represents a real data disaster that could impact your business. As you approach them, you'll see what they mean for your company. Jump over them to avoid the consequences!
                </p>
                <h3 style="margin-top: 20px;">‚å®Ô∏è Controls</h3>
                <ul>
                    <li><strong>SPACE / TAP</strong> - Jump over hazards</li>
                    <li><strong>‚Üë / ‚Üì ARROWS</strong> - Fine movement</li>
                    <li><strong>P</strong> - Pause game</li>
                    <li><strong>M</strong> - Toggle sound</li>
                </ul>
            </div>
            
            <button id="start-game-btn" class="btn btn-primary btn-full">
                ‚ö° Start Run
            </button>
        </div>
    </div>

    <!-- End Screen Modal -->
    <div id="end-modal" class="modal-overlay hidden" role="dialog" aria-labelledby="end-title" aria-modal="true">
        <div class="modal end-screen">
            <div class="logo-container">
                <div class="logo-icon" aria-hidden="true">üéÆ</div>
                <h1 id="end-title" class="game-title">Run Complete!</h1>
            </div>
            
            <p class="welcome-text" id="end-message">Great effort, Player!</p>
            
            <div class="score-display">
                <p class="score-label">Your Score</p>
                <p class="score-value" id="final-score">0</p>
            </div>
            
            <div class="badge-earned hidden" id="badge-section">
                <h4 id="badge-title">üèÖ Badge Unlocked!</h4>
                <p id="badge-description">Achievement unlocked</p>
            </div>

            <!-- Threats Avoided Summary -->
            <div class="threats-avoided-section" id="threats-avoided-section" style="background: rgba(0, 255, 136, 0.1); border: 2px solid rgba(0, 255, 136, 0.3); border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #00FF88; margin-bottom: 15px; font-size: 1.1rem;">üõ°Ô∏è Threats Vault Protected You From</h4>
                <div id="threats-count" style="font-size: 2rem; font-weight: bold; color: #FFFFFF; margin-bottom: 10px;">0</div>
                <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 15px;">Data disasters avoided this run</p>
                <div id="threats-list" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 15px;">
                    <!-- Threat badges will be inserted here -->
                </div>
                <p id="vault-protection-message" style="color: #00FF88; font-size: 0.95rem; font-style: italic;">
                    With AutoRABIT Vault, recovery from any of these would take less than 15 minutes.
                </p>
            </div>
            
            <div class="vault-tip">
                <strong>üí° Vault Tip:</strong> In real life, data disasters strike without warning. AutoRABIT Vault provides enterprise-grade backup & recovery for your Salesforce org‚Äîso you never lose critical data.
            </div>
            
            <div class="share-section">
                <h4>üì¢ Share Your Score</h4>
                <div class="share-buttons">
                    <button class="btn btn-social btn-x" id="share-x" aria-label="Share on X">
                        ùïè Post
                    </button>
                    <button class="btn btn-social btn-linkedin" id="share-linkedin" aria-label="Share on LinkedIn">
                        in Share
                    </button>
                    <button class="btn btn-social btn-email" id="email-results" aria-label="Email results to yourself">
                        ‚úâÔ∏è Email Me
                    </button>
                    <button class="btn btn-social btn-friend" id="email-friend" aria-label="Email to a friend">
                        üë• Send to Friend
                    </button>
                </div>
            </div>
            
            <div class="action-buttons">
                <a href="#" id="cta-button" class="btn btn-cta btn-full" target="_blank" rel="noopener">
                    üõ°Ô∏è Start Free Vault Trial
                </a>
                <button id="play-again-btn" class="btn btn-secondary btn-full">
                    üîÑ Play Again
                </button>
            </div>
        </div>
    </div>

    <!-- Email to Friend Modal -->
    <div id="friend-modal" class="friend-modal hidden" role="dialog" aria-labelledby="friend-modal-title" aria-modal="true">
        <div class="friend-modal-content">
            <h3 id="friend-modal-title">üìß Challenge a Friend!</h3>
            <p style="color: var(--text-muted); margin-bottom: 20px; font-size: 0.9rem;">Send your score and challenge them to beat it!</p>
            <input type="email" id="friend-email" placeholder="friend@company.com" aria-label="Friend's email address">
            <div class="friend-modal-buttons">
                <button class="btn btn-secondary" id="friend-cancel">Cancel</button>
                <button class="btn btn-primary" id="friend-send">Send Challenge</button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="hidden">
        <canvas id="gameCanvas" aria-label="Recovery Runner Game"></canvas>
        
        <!-- HUD -->
        <div class="hud" role="status" aria-live="polite">
            <div class="hud-item">
                <div class="hud-score">
                    Score: <span id="hud-score">0</span>
                </div>
                <div class="hud-difficulty" id="hud-difficulty">
                    <span id="hud-difficulty-icon">üèÉ</span> <span id="hud-difficulty-name">Normal</span>
                </div>
            </div>
            <div class="hud-item hud-controls">
                <button class="hud-btn" id="pause-btn" aria-label="Pause game">‚è∏Ô∏è Pause</button>
                <button class="hud-btn" id="mute-btn" aria-label="Toggle sound">üîä</button>
            </div>
        </div>
        
        <!-- Power-up Indicator -->
        <div class="power-up-indicator hidden" id="power-up-indicator">
            üõ°Ô∏è VAULT SHIELD ACTIVE
        </div>
        
        <!-- Wave Warning Banner -->
        <div class="wave-banner hidden" id="wave-banner">
            ‚ö†Ô∏è INCOMING WAVE ‚ö†Ô∏è
        </div>
        
        <!-- Combo Display -->
        <div class="combo-display hidden" id="combo-display">
            <span id="combo-count">1</span>x COMBO
        </div>
        
        <!-- Pause Overlay -->
        <div class="pause-overlay hidden" id="pause-overlay">
            <div class="pause-content">
                <h2>‚è∏Ô∏è PAUSED</h2>
                <button class="btn btn-primary" id="resume-btn">‚ñ∂Ô∏è Resume</button>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobile-controls">
            <button class="mobile-btn" id="mobile-jump" aria-label="Jump">‚¨ÜÔ∏è</button>
        </div>
    </div>

    <script>
    /* ==========================================
       RECOVERY RUNNER - GAME ENGINE
       AutoRABIT Vault Marketing Game
       ========================================== */

    // ==========================================
    // CONFIGURATION & CONSTANTS
    // ==========================================
    const CONFIG = {
        CANVAS_WIDTH: 900,
        CANVAS_HEIGHT: 500,
        GROUND_HEIGHT: 80,
        GRAVITY: 0.8,
        JUMP_FORCE: -15,
        INITIAL_SPEED: 6,
        MAX_SPEED: 15,
        SPEED_INCREMENT: 0.001,
        ORB_SPAWN_RATE: 0.02,
        HAZARD_SPAWN_RATE: 0.015,
        POWERUP_SPAWN_RATE: 0.003,
        SHIELD_DURATION: 5000,
        PLAYER_WIDTH: 50,
        PLAYER_HEIGHT: 60
    };

    // Difficulty presets - affects speed and spawn rates
    // Hazard spawn rates significantly reduced to allow educational reading
    const DIFFICULTY_PRESETS = {
        easy: {
            name: 'Easy',
            description: 'Relaxed pace - Perfect for reading data challenges',
            initialSpeed: 3,
            maxSpeed: 6,
            speedIncrement: 0.0003,
            hazardSpawnRate: 0.003,      // Very low - ~1 hazard every 5-6 seconds
            minHazardGap: 400,            // Minimum 400px between hazards
            orbSpawnRate: 0.02,
            powerupSpawnRate: 0.006,
            shieldDuration: 8000,
            scoreMultiplier: 0.5,
            icon: 'üê¢'
        },
        normal: {
            name: 'Normal',
            description: 'Balanced challenge for most players',
            initialSpeed: 5,
            maxSpeed: 10,
            speedIncrement: 0.0008,
            hazardSpawnRate: 0.006,       // Reduced - ~1 hazard every 3 seconds
            minHazardGap: 300,            // Minimum 300px between hazards
            orbSpawnRate: 0.018,
            powerupSpawnRate: 0.004,
            shieldDuration: 6000,
            scoreMultiplier: 1.0,
            icon: 'üèÉ'
        },
        hard: {
            name: 'Hard',
            description: 'Fast & intense - For experienced players',
            initialSpeed: 7,
            maxSpeed: 14,
            speedIncrement: 0.001,
            hazardSpawnRate: 0.01,        // Reduced - ~1 hazard every 1.5-2 seconds
            minHazardGap: 200,            // Minimum 200px between hazards
            orbSpawnRate: 0.015,
            powerupSpawnRate: 0.003,
            shieldDuration: 5000,
            scoreMultiplier: 1.5,
            icon: 'üî•'
        },
        extreme: {
            name: 'Extreme',
            description: 'Ultimate challenge - Only the brave survive!',
            initialSpeed: 9,
            maxSpeed: 18,
            speedIncrement: 0.0015,
            hazardSpawnRate: 0.015,       // Reduced - ~1 hazard every 1-1.5 seconds
            minHazardGap: 150,            // Minimum 150px between hazards
            orbSpawnRate: 0.012,
            powerupSpawnRate: 0.002,
            shieldDuration: 4000,
            scoreMultiplier: 2.0,
            icon: 'üíÄ'
        }
    };

            // Hazard descriptions with business impact
    const HAZARD_DESCRIPTIONS = {
        'Loan Overwrite': 'Critical loan data accidentally overwritten - can result in regulatory fines and customer trust loss',
        'Compliance Breach': 'Violation of banking regulations - leads to massive fines and potential license revocation',
        'Audit Fail': 'Failed compliance audit - triggers regulatory investigations and business disruption',
        'Rate Sync Error': 'Interest rate synchronization failure - causes incorrect loan calculations and financial losses',
        'Document Leak': 'Sensitive banking documents exposed - results in data breach penalties and reputation damage',
        'FlexCard Corruption': 'Customer-facing card component fails - impacts patient experience and operational efficiency',
        'Process Fail': 'Critical healthcare process breaks down - delays patient care and violates service level agreements',
        'HIPAA Breach': 'Protected health information exposed - triggers $1M+ fines and legal liability',
        'Record Sync Error': 'Patient record synchronization fails - causes duplicate records and treatment errors',
        'PHI Exposure': 'Protected health information leaked - results in HIPAA violations and patient trust loss',
        'Cart Corruption': 'Shopping cart data corrupted - causes lost sales and customer frustration',
        'Order Sync Fail': 'Order synchronization failure - results in inventory mismatches and shipping errors',
        'Inventory Wipe': 'Product inventory data deleted - causes stockouts and revenue loss',
        'Price Override': 'Product pricing accidentally changed - leads to incorrect charges and customer complaints',
        'Customer Loss': 'Customer data permanently lost - results in relationship damage and revenue decline',
        'Metadata Loss': 'Salesforce configuration and customizations deleted - requires weeks to rebuild',
        'API Limit Hit': 'API usage exceeds limits - causes integration failures and business process breakdown',
        'Sandbox Wipe': 'Development sandbox data lost - delays releases and increases development costs',
        'Config Corrupt': 'Salesforce configuration corrupted - breaks business processes and user workflows',
        'Deploy Fail': 'Deployment failure with data loss - requires rollback and causes production downtime'
    };

    // Vault solutions and hazard metadata for educational content
    const VAULT_SOLUTIONS = {
        'Loan Overwrite': {
            icon: 'üíæ',
            category: 'data_loss',
            impact: 'üí∞ $50K+ regulatory fines',
            severity: 'critical',
            vaultSolution: 'Point-in-time recovery restores exact loan data in under 5 minutes',
            recoveryTime: '< 5 min'
        },
        'Compliance Breach': {
            icon: '‚öñÔ∏è',
            category: 'compliance',
            impact: 'üìã License revocation risk',
            severity: 'critical',
            vaultSolution: 'Automated compliance snapshots ensure audit-ready data restoration',
            recoveryTime: '< 10 min'
        },
        'Audit Fail': {
            icon: 'üìä',
            category: 'compliance',
            impact: 'üîç Regulatory investigation',
            severity: 'high',
            vaultSolution: 'Complete audit trail with granular recovery to any point in time',
            recoveryTime: '< 15 min'
        },
        'Rate Sync Error': {
            icon: 'üîÑ',
            category: 'sync',
            impact: 'üí∏ Financial calculation errors',
            severity: 'high',
            vaultSolution: 'Selective field-level recovery corrects sync issues without full restore',
            recoveryTime: '< 3 min'
        },
        'Document Leak': {
            icon: 'üîì',
            category: 'security',
            impact: 'üõ°Ô∏è Data breach penalties',
            severity: 'critical',
            vaultSolution: 'Instant rollback to pre-breach state with complete data integrity',
            recoveryTime: '< 5 min'
        },
        'FlexCard Corruption': {
            icon: 'üé¥',
            category: 'data_loss',
            impact: 'üòû Patient experience degraded',
            severity: 'medium',
            vaultSolution: 'Component-level recovery restores UI configurations instantly',
            recoveryTime: '< 2 min'
        },
        'Process Fail': {
            icon: '‚öôÔ∏è',
            category: 'sync',
            impact: '‚è±Ô∏è Patient care delays',
            severity: 'high',
            vaultSolution: 'Process definition recovery with dependency tracking',
            recoveryTime: '< 5 min'
        },
        'HIPAA Breach': {
            icon: 'üè•',
            category: 'compliance',
            impact: 'üí∞ $1M+ HIPAA fines',
            severity: 'critical',
            vaultSolution: 'Encrypted backups with instant recovery maintain HIPAA compliance',
            recoveryTime: '< 10 min'
        },
        'Record Sync Error': {
            icon: 'üîÑ',
            category: 'sync',
            impact: '‚ö†Ô∏è Treatment errors possible',
            severity: 'high',
            vaultSolution: 'Record-level comparison and selective sync correction',
            recoveryTime: '< 3 min'
        },
        'PHI Exposure': {
            icon: 'üîê',
            category: 'security',
            impact: 'üìâ Patient trust loss',
            severity: 'critical',
            vaultSolution: 'Immediate data state rollback with exposure timeline tracking',
            recoveryTime: '< 5 min'
        },
        'Cart Corruption': {
            icon: 'üõí',
            category: 'data_loss',
            impact: 'üí∏ Lost sales revenue',
            severity: 'high',
            vaultSolution: 'Transaction-aware recovery preserves customer cart state',
            recoveryTime: '< 2 min'
        },
        'Order Sync Fail': {
            icon: 'üì¶',
            category: 'sync',
            impact: 'üì¶ Shipping errors',
            severity: 'high',
            vaultSolution: 'Order state reconciliation with inventory sync validation',
            recoveryTime: '< 5 min'
        },
        'Inventory Wipe': {
            icon: 'üìã',
            category: 'data_loss',
            impact: 'üö´ Stockout crisis',
            severity: 'critical',
            vaultSolution: 'Bulk inventory restoration with real-time stock level recovery',
            recoveryTime: '< 10 min'
        },
        'Price Override': {
            icon: 'üí≤',
            category: 'data_loss',
            impact: 'üò§ Customer complaints',
            severity: 'medium',
            vaultSolution: 'Price history tracking with selective field restoration',
            recoveryTime: '< 2 min'
        },
        'Customer Loss': {
            icon: 'üë•',
            category: 'data_loss',
            impact: 'üìâ Revenue decline',
            severity: 'critical',
            vaultSolution: 'Complete customer record recovery with relationship preservation',
            recoveryTime: '< 5 min'
        },
        'Metadata Loss': {
            icon: 'üóÇÔ∏è',
            category: 'data_loss',
            impact: 'üîß Weeks to rebuild',
            severity: 'critical',
            vaultSolution: 'Full metadata backup with dependency-aware restoration',
            recoveryTime: '< 15 min'
        },
        'API Limit Hit': {
            icon: 'üîå',
            category: 'sync',
            impact: '‚õî Integration failures',
            severity: 'high',
            vaultSolution: 'Cached data recovery bypasses API limits during restoration',
            recoveryTime: '< 5 min'
        },
        'Sandbox Wipe': {
            icon: 'üèñÔ∏è',
            category: 'data_loss',
            impact: 'üìÖ Release delays',
            severity: 'high',
            vaultSolution: 'Sandbox-specific backups with rapid environment recreation',
            recoveryTime: '< 20 min'
        },
        'Config Corrupt': {
            icon: '‚öôÔ∏è',
            category: 'data_loss',
            impact: 'üî• Process breakdown',
            severity: 'critical',
            vaultSolution: 'Configuration versioning with instant rollback capability',
            recoveryTime: '< 5 min'
        },
        'Deploy Fail': {
            icon: 'üöÄ',
            category: 'sync',
            impact: '‚è∞ Production downtime',
            severity: 'critical',
            vaultSolution: 'Pre-deployment snapshots enable instant rollback on failure',
            recoveryTime: '< 3 min'
        }
    };

    // Category colors for distinct hazard visuals
    const HAZARD_CATEGORIES = {
        data_loss: { color: '#FF6B6B', shape: 'broken_disk' },
        compliance: { color: '#FFD93D', shape: 'scale' },
        security: { color: '#FF4757', shape: 'broken_lock' },
        sync: { color: '#FFA502', shape: 'broken_sync' }
    };

    // Industry-specific themes
    const THEMES = {
        banking: {
            name: 'nCino Banking',
            greeting: 'Secure your Banking Data!',
            hazards: ['Loan Overwrite', 'Compliance Breach', 'Audit Fail', 'Rate Sync Error', 'Document Leak'],
            collectibles: ['Secure Loan', 'Compliance Check', 'Audit Pass'],
            colors: {
                primary: '#FFFFFF',
                secondary: '#888888',
                accent: '#FFFFFF',
                hazard: '#FF4444',
                bg: '#000000'
            },
            badge: { name: 'nCino Guardian', threshold: 500, icon: 'üè¶' },
            waves: ['Regulatory Fine Wave', 'Loan Default Storm', 'Compliance Audit Surge']
        },
        healthcare: {
            name: 'OmniStudio Health',
            greeting: 'Protect Patient Data!',
            hazards: ['FlexCard Corruption', 'Process Fail', 'HIPAA Breach', 'Record Sync Error', 'PHI Exposure'],
            collectibles: ['OmniScript', 'FlexCard', 'DataRaptor'],
            colors: {
                primary: '#FFFFFF',
                secondary: '#888888',
                accent: '#FFFFFF',
                hazard: '#FF4444',
                bg: '#000000'
            },
            badge: { name: 'OmniStudio Healer', threshold: 500, icon: '‚öïÔ∏è' },
            waves: ['UI Glitch Swarm', 'Integration Crash', 'Data Flow Disruption']
        },
        retail: {
            name: 'OmniStudio Commerce',
            greeting: 'Guard Your Commerce Data!',
            hazards: ['Cart Corruption', 'Order Sync Fail', 'Inventory Wipe', 'Price Override', 'Customer Loss'],
            collectibles: ['Order Data', 'Customer Record', 'Product Sync'],
            colors: {
                primary: '#FFFFFF',
                secondary: '#888888',
                accent: '#FFFFFF',
                hazard: '#FF4444',
                bg: '#000000'
            },
            badge: { name: 'Commerce Champion', threshold: 500, icon: 'üõí' },
            waves: ['Flash Sale Crash', 'Inventory Chaos', 'Cart Abandonment Storm']
        },
        other: {
            name: 'Salesforce Org',
            greeting: 'Defend Your Salesforce Org!',
            hazards: ['Metadata Loss', 'API Limit Hit', 'Sandbox Wipe', 'Config Corrupt', 'Deploy Fail'],
            collectibles: ['Sandbox Orb', 'Metadata Pack', 'Config Backup'],
            colors: {
                primary: '#FFFFFF',
                secondary: '#888888',
                accent: '#FFFFFF',
                hazard: '#FF4444',
                bg: '#000000'
            },
            badge: { name: 'Salesforce Survivor', threshold: 500, icon: '‚òÅÔ∏è' },
            waves: ['Ransomware Attack', 'Mass Delete Storm', 'Integration Nightmare']
        }
    };

    // ==========================================
    // GAME STATE
    // ==========================================
    let gameState = {
        player: null,
        isRunning: false,
        isPaused: false,
        score: 0,
        highScore: 0,
        speed: CONFIG.INITIAL_SPEED,
        hazards: [],
        orbs: [],
        powerups: [],
        particles: [],
        bgElements: [],
        shieldActive: false,
        shieldEndTime: 0,
        waveTimer: 0,
        currentWave: null,
        soundEnabled: true,
        theme: THEMES.other,
        userData: { name: '', email: '', industry: '' },
        // Combo system
        combo: 0,
        maxCombo: 0,
        comboTimer: 0,
        lastCollectTime: 0,
        multiplier: 1,
        distance: 0,
        // Difficulty settings
        difficulty: 'normal',
        difficultySettings: DIFFICULTY_PRESETS.normal,
        // Learning mode
        learningMode: false,
        learningPaused: false,
        currentLearningHazard: null,
        learningResumeTimer: null,
        // Threat tracking
        threatsAvoided: 0,
        threatsAvoidedList: [],
        // Protected flash effects
        protectedFlash: null
    };

    // ==========================================
    // DOM ELEMENTS
    // ==========================================
    const elements = {
        registrationModal: document.getElementById('registration-modal'),
        startModal: document.getElementById('start-modal'),
        endModal: document.getElementById('end-modal'),
        gameContainer: document.getElementById('game-container'),
        canvas: document.getElementById('gameCanvas'),
        registrationForm: document.getElementById('registration-form'),
        playerName: document.getElementById('player-name'),
        playerEmail: document.getElementById('player-email'),
        playerIndustry: document.getElementById('player-industry'),
        nameError: document.getElementById('name-error'),
        emailError: document.getElementById('email-error'),
        welcomeText: document.getElementById('welcome-text'),
        industryIntro: document.getElementById('industry-intro'),
        highScoreValue: document.getElementById('high-score-value'),
        startGameBtn: document.getElementById('start-game-btn'),
        endMessage: document.getElementById('end-message'),
        finalScore: document.getElementById('final-score'),
        badgeSection: document.getElementById('badge-section'),
        badgeTitle: document.getElementById('badge-title'),
        badgeDescription: document.getElementById('badge-description'),
        ctaButton: document.getElementById('cta-button'),
        playAgainBtn: document.getElementById('play-again-btn'),
        shareX: document.getElementById('share-x'),
        shareLinkedIn: document.getElementById('share-linkedin'),
        emailResults: document.getElementById('email-results'),
        emailFriend: document.getElementById('email-friend'),
        friendModal: document.getElementById('friend-modal'),
        friendEmail: document.getElementById('friend-email'),
        friendCancel: document.getElementById('friend-cancel'),
        friendSend: document.getElementById('friend-send'),
        hudScore: document.getElementById('hud-score'),
        pauseBtn: document.getElementById('pause-btn'),
        muteBtn: document.getElementById('mute-btn'),
        pauseOverlay: document.getElementById('pause-overlay'),
        resumeBtn: document.getElementById('resume-btn'),
        powerUpIndicator: document.getElementById('power-up-indicator'),
        mobileJump: document.getElementById('mobile-jump'),
        difficultyOptions: document.getElementById('difficulty-options'),
        hudDifficultyIcon: document.getElementById('hud-difficulty-icon'),
        hudDifficultyName: document.getElementById('hud-difficulty-name'),
        // Mode toggle elements
        modeToggle: document.getElementById('mode-toggle'),
        arcadeModeBtn: document.getElementById('arcade-mode-btn'),
        learningModeBtn: document.getElementById('learning-mode-btn'),
        modeDescription: document.getElementById('mode-description')
    };

    const ctx = elements.canvas.getContext('2d');

    // ==========================================
    // AUDIO SYSTEM (Web Audio API)
    // ==========================================
    let audioCtx = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playSound(type) {
        if (!gameState.soundEnabled || !audioCtx) return;
        
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        switch(type) {
            case 'jump':
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
                break;
            case 'collect':
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.1);
                break;
            case 'powerup':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.4);
                break;
            case 'hit':
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
                break;
            case 'wave':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.4);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.5);
                break;
        }
    }

    // ==========================================
    // ANALYTICS STUBS
    // ==========================================
    function trackEvent(eventName, params = {}) {
        // Google Analytics 4 event tracking stub
        // Uncomment and configure when ready to deploy:
        /*
        if (typeof gtag !== 'undefined') {
            gtag('event', eventName, params);
        }
        */
        console.log('[Analytics]', eventName, params);
    }

    // ==========================================
    // LOCAL STORAGE UTILITIES
    // ==========================================
    function saveUserData(data) {
        try {
            localStorage.setItem('recoveryRunner_user', JSON.stringify(data));
        } catch (e) {
            console.warn('Could not save user data:', e);
        }
    }

    function loadUserData() {
        try {
            const data = localStorage.getItem('recoveryRunner_user');
            return data ? JSON.parse(data) : null;
        } catch (e) {
            console.warn('Could not load user data:', e);
            return null;
        }
    }

    function saveHighScore(score) {
        try {
            const currentHigh = parseInt(localStorage.getItem('recoveryRunner_highScore') || '0');
            if (score > currentHigh) {
                localStorage.setItem('recoveryRunner_highScore', score.toString());
                // Global leaderboard stub
                console.log('[Leaderboard] New high score:', score, 'for user:', gameState.userData.email);
                return true;
            }
        } catch (e) {
            console.warn('Could not save high score:', e);
        }
        return false;
    }

    function loadHighScore() {
        try {
            return parseInt(localStorage.getItem('recoveryRunner_highScore') || '0');
        } catch (e) {
            return 0;
        }
    }

    // ==========================================
    // VALIDATION
    // ==========================================
    function validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }

    // ==========================================
    // GAME CLASSES
    // ==========================================
    class Player {
        constructor() {
            this.x = 100;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - CONFIG.PLAYER_HEIGHT;
            this.width = CONFIG.PLAYER_WIDTH;
            this.height = CONFIG.PLAYER_HEIGHT;
            this.velocityY = 0;
            this.isJumping = false;
            this.frame = 0;
            this.animTimer = 0;
        }

        jump() {
            if (!this.isJumping) {
                this.velocityY = CONFIG.JUMP_FORCE;
                this.isJumping = true;
                playSound('jump');
            }
        }

        update() {
            // Apply gravity
            this.velocityY += CONFIG.GRAVITY;
            this.y += this.velocityY;

            // Ground collision
            const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
            if (this.y >= groundY) {
                this.y = groundY;
                this.velocityY = 0;
                this.isJumping = false;
            }

            // Animation
            this.animTimer++;
            if (this.animTimer > 5) {
                this.frame = (this.frame + 1) % 4;
                this.animTimer = 0;
            }
        }

        draw(ctx) {
            const theme = gameState.theme;
            
            // Draw shield effect if active
            if (gameState.shieldActive) {
                ctx.save();
                // Outer shield ring
                const shieldPulse = Math.sin(Date.now() / 100) * 5 + 45;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, shieldPulse, 0, Math.PI * 2);
                ctx.strokeStyle = theme.colors.primary;
                ctx.lineWidth = 3;
                ctx.shadowColor = theme.colors.primary;
                ctx.shadowBlur = 30;
                ctx.stroke();
                
                // Inner shield fill
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width * 0.75, 0, Math.PI * 2);
                ctx.fillStyle = `${theme.colors.primary}22`;
                ctx.fill();
                
                // Hexagon pattern
                ctx.strokeStyle = `${theme.colors.primary}44`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + Date.now() / 2000;
                    const x1 = this.x + this.width/2 + Math.cos(angle) * 35;
                    const y1 = this.y + this.height/2 + Math.sin(angle) * 35;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/2, this.y + this.height/2);
                    ctx.lineTo(x1, y1);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Bot glow effect
            ctx.save();
            ctx.shadowColor = theme.colors.primary;
            ctx.shadowBlur = 15;
            
            // Bot body (rounded)
            const bodyGrad = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
            bodyGrad.addColorStop(0, theme.colors.primary);
            bodyGrad.addColorStop(1, theme.colors.secondary);
            ctx.fillStyle = bodyGrad;
            
            // Main body
            ctx.beginPath();
            ctx.roundRect(this.x + 8, this.y + 18, this.width - 16, this.height - 30, 8);
            ctx.fill();

            // Bot head (with visor)
            ctx.fillStyle = theme.colors.secondary;
            ctx.beginPath();
            ctx.roundRect(this.x + 8, this.y + 2, this.width - 16, 22, [8, 8, 0, 0]);
            ctx.fill();

            // Visor (eyes area)
            ctx.fillStyle = '#0D0221';
            ctx.beginPath();
            ctx.roundRect(this.x + 12, this.y + 6, this.width - 24, 14, 4);
            ctx.fill();

            // Eyes (animated, glowing)
            const eyeOffset = Math.sin(this.animTimer * 0.3) * 2;
            const eyeGlow = ctx.createRadialGradient(
                this.x + 19 + eyeOffset, this.y + 12, 0,
                this.x + 19 + eyeOffset, this.y + 12, 8
            );
            eyeGlow.addColorStop(0, '#fff');
            eyeGlow.addColorStop(0.5, theme.colors.primary);
            eyeGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = eyeGlow;
            ctx.beginPath();
            ctx.arc(this.x + 19 + eyeOffset, this.y + 12, 5, 0, Math.PI * 2);
            ctx.fill();
            
            const eyeGlow2 = ctx.createRadialGradient(
                this.x + 32 + eyeOffset, this.y + 12, 0,
                this.x + 32 + eyeOffset, this.y + 12, 8
            );
            eyeGlow2.addColorStop(0, '#fff');
            eyeGlow2.addColorStop(0.5, theme.colors.accent);
            eyeGlow2.addColorStop(1, 'transparent');
            ctx.fillStyle = eyeGlow2;
            ctx.beginPath();
            ctx.arc(this.x + 32 + eyeOffset, this.y + 12, 5, 0, Math.PI * 2);
            ctx.fill();

            // Running legs animation
            const legOffset = Math.sin(this.frame * Math.PI / 2) * 10;
            ctx.fillStyle = theme.colors.primary;
            ctx.beginPath();
            ctx.roundRect(this.x + 12, this.y + this.height - 18 + legOffset, 10, 18 - Math.max(0, legOffset), 3);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(this.x + 28, this.y + this.height - 18 - legOffset, 10, 18 + Math.min(0, legOffset), 3);
            ctx.fill();

            // Antenna with energy orb
            ctx.strokeStyle = theme.colors.accent;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width/2, this.y + 2);
            ctx.lineTo(this.x + this.width/2, this.y - 12);
            ctx.stroke();
            
            // Antenna orb (pulsing)
            const orbPulse = Math.sin(Date.now() / 150) * 2 + 5;
            const orbGrad = ctx.createRadialGradient(
                this.x + this.width/2, this.y - 14, 0,
                this.x + this.width/2, this.y - 14, orbPulse + 3
            );
            orbGrad.addColorStop(0, '#fff');
            orbGrad.addColorStop(0.4, theme.colors.accent);
            orbGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = orbGrad;
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y - 14, orbPulse, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();

            // Jet trail when jumping
            if (this.isJumping && this.velocityY < 0) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = theme.colors.primary;
                    ctx.globalAlpha = 0.5 - i * 0.1;
                    ctx.beginPath();
                    ctx.arc(
                        this.x + 15 + Math.random() * 5, 
                        this.y + this.height + i * 8 + Math.random() * 3,
                        4 - i * 0.5,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(
                        this.x + 35 + Math.random() * 5, 
                        this.y + this.height + i * 8 + Math.random() * 3,
                        4 - i * 0.5,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        getBounds() {
            return {
                x: this.x + 5,
                y: this.y + 5,
                width: this.width - 10,
                height: this.height - 10
            };
        }
    }

    class Hazard {
        constructor(type) {
            this.x = CONFIG.CANVAS_WIDTH + 50;
            this.width = 70;  // Increased from 50
            this.height = 70; // Increased from 50
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
            this.type = type;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.passed = false; // Track if player successfully jumped over
            this.descriptionShown = false;
            
            // Get hazard metadata
            const meta = VAULT_SOLUTIONS[type] || {};
            this.icon = meta.icon || '‚ö†Ô∏è';
            this.category = meta.category || 'data_loss';
            this.impact = meta.impact || '‚ö†Ô∏è Business risk';
            this.severity = meta.severity || 'medium';
            this.vaultSolution = meta.vaultSolution || 'Vault provides instant recovery';
            this.recoveryTime = meta.recoveryTime || '< 5 min';
            
            // Category-based color
            const catMeta = HAZARD_CATEGORIES[this.category] || HAZARD_CATEGORIES.data_loss;
            this.categoryColor = catMeta.color;
        }

        update() {
            if (!gameState.learningPaused) {
                this.x -= gameState.speed;
            }
            this.pulsePhase += 0.1;
            
            // Check if player passed this hazard (for tracking threats avoided)
            if (!this.passed && gameState.player) {
                const playerRight = gameState.player.x + gameState.player.width;
                if (this.x + this.width < playerRight) {
                    this.passed = true;
                    // Only count if player didn't collide (handled elsewhere)
                }
            }
        }

        draw(ctx) {
            const theme = gameState.theme;
            const pulse = Math.sin(this.pulsePhase) * 0.12 + 1;
            const rotation = Math.sin(this.pulsePhase * 0.5) * 0.08;
            
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(rotation);
            ctx.scale(pulse, pulse);
            ctx.translate(-this.width/2, -this.height/2);

            // Glow effect with category color
            ctx.shadowColor = this.categoryColor;
            ctx.shadowBlur = 30;

            // Hazard body - larger with category-based gradient
            const hazardGrad = ctx.createRadialGradient(
                this.width/2, this.height/2, 0,
                this.width/2, this.height/2, this.width/2
            );
            hazardGrad.addColorStop(0, '#fff');
            hazardGrad.addColorStop(0.3, this.categoryColor);
            hazardGrad.addColorStop(1, this.categoryColor + '88');
            ctx.fillStyle = hazardGrad;
            
            // Draw shape based on category
            ctx.beginPath();
            if (this.category === 'compliance') {
                // Scale/balance shape for compliance
                this.drawScaleShape(ctx);
            } else if (this.category === 'security') {
                // Broken lock shape for security
                this.drawLockShape(ctx);
            } else if (this.category === 'sync') {
                // Broken sync/arrows shape
                this.drawSyncShape(ctx);
            } else {
                // Broken disk shape for data loss
                this.drawDiskShape(ctx);
            }

            // Icon in center (larger)
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText(this.icon, this.width/2, this.height/2);

            // Electric arcs
            ctx.strokeStyle = this.categoryColor;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2 / 4) + this.pulsePhase;
                ctx.beginPath();
                ctx.moveTo(this.width/2 + Math.cos(angle) * 18, this.height/2 + Math.sin(angle) * 18);
                ctx.lineTo(this.width/2 + Math.cos(angle) * 30, this.height/2 + Math.sin(angle) * 30);
                ctx.stroke();
            }

            ctx.restore();

            // Label below hazard - LARGER with background
            ctx.save();
            const labelText = this.type.toUpperCase();
            ctx.font = 'bold 14px Rajdhani, sans-serif';
            const labelWidth = ctx.measureText(labelText).width + 16;
            const labelX = this.x + this.width/2 - labelWidth/2;
            const labelY = this.y + this.height + 6;
            
            // Label background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(labelX, labelY, labelWidth, 22);
            ctx.strokeStyle = this.categoryColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(labelX, labelY, labelWidth, 22);
            
            // Label text
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = this.categoryColor;
            ctx.shadowBlur = 8;
            ctx.fillText(labelText, this.x + this.width/2, labelY + 11);
            ctx.restore();
            
            // Show description if hazard is close to player - EARLIER now (400px)
            this.drawDescription(ctx);
        }

        drawDescription(ctx) {
            const playerX = gameState.player ? gameState.player.x : 0;
            const distance = this.x - playerX;
            
            // Show description earlier (400px away) and keep showing until 50px
            if (distance < 400 && distance > 50 && HAZARD_DESCRIPTIONS[this.type]) {
                const desc = HAZARD_DESCRIPTIONS[this.type];
                const maxWidth = 300;
                
                ctx.save();
                ctx.font = '13px Rajdhani, sans-serif';
                const lines = wrapText(ctx, desc, maxWidth - 20, '13px Rajdhani, sans-serif');
                
                // Add impact line
                const impactLine = this.impact;
                const boxHeight = (lines.length + 2) * 18 + 20;
                const boxX = Math.min(this.x + this.width/2 - maxWidth/2, CONFIG.CANVAS_WIDTH - maxWidth - 20);
                const boxY = Math.max(70, this.y - boxHeight - 15);
                
                // Description box with gradient background
                const boxGrad = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight);
                boxGrad.addColorStop(0, 'rgba(20, 20, 30, 0.95)');
                boxGrad.addColorStop(1, 'rgba(10, 10, 20, 0.98)');
                ctx.fillStyle = boxGrad;
                ctx.strokeStyle = this.categoryColor;
                ctx.lineWidth = 2;
                
                // Rounded rectangle
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, maxWidth, boxHeight, 8);
                ctx.fill();
                ctx.stroke();
                
                // Header with icon
                ctx.fillStyle = this.categoryColor;
                ctx.font = 'bold 15px Rajdhani, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`${this.icon} ${this.type.toUpperCase()}`, boxX + 12, boxY + 22);
                
                // Impact badge
                ctx.fillStyle = '#FFAA00';
                ctx.font = 'bold 12px Rajdhani, sans-serif';
                ctx.fillText(impactLine, boxX + 12, boxY + 42);
                
                // Separator line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(boxX + 12, boxY + 52);
                ctx.lineTo(boxX + maxWidth - 12, boxY + 52);
                ctx.stroke();
                
                // Description text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '13px Rajdhani, sans-serif';
                ctx.shadowBlur = 0;
                lines.forEach((line, i) => {
                    ctx.fillText(line, boxX + 12, boxY + 72 + i * 18);
                });
                
                ctx.restore();
            }
        }

        // Shape drawing methods for different categories
        drawScaleShape(ctx) {
            // Balance/scale shape for compliance
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner hexagon
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2 / 6) - Math.PI/2;
                const px = cx + Math.cos(angle) * (r * 0.6);
                const py = cy + Math.sin(angle) * (r * 0.6);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        drawLockShape(ctx) {
            // Broken lock shape for security
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Crack effect
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 15);
            ctx.lineTo(cx + 5, cy);
            ctx.lineTo(cx - 8, cy + 12);
            ctx.stroke();
        }

        drawSyncShape(ctx) {
            // Broken sync arrows for sync errors
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Broken circle arrows
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.5, 0, Math.PI * 1.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.5, Math.PI, Math.PI * 2.2);
            ctx.stroke();
        }

        drawDiskShape(ctx) {
            // Broken disk shape for data loss
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner broken disk
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Crack
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + r * 0.3, cy - r * 0.3);
            ctx.lineTo(cx - r * 0.3, cy + r * 0.3);
            ctx.stroke();
        }

        isOffScreen() {
            return this.x + this.width < 0;
        }

        getBounds() {
            return { x: this.x + 8, y: this.y + 8, width: this.width - 16, height: this.height - 16 };
        }
    }

    class Orb {
        constructor() {
            this.x = CONFIG.CANVAS_WIDTH + 30;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 80 - Math.random() * 100;
            this.radius = 15;
            this.collected = false;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.type = gameState.theme.collectibles[Math.floor(Math.random() * gameState.theme.collectibles.length)];
        }

        update() {
            this.x -= gameState.speed;
            this.pulsePhase += 0.15;
        }

        draw(ctx) {
            if (this.collected) return;
            
            const theme = gameState.theme;
            const pulse = Math.sin(this.pulsePhase) * 4;
            const bobY = Math.sin(this.pulsePhase * 0.7) * 3;

            ctx.save();
            
            // Outer glow rings
            ctx.shadowColor = theme.colors.accent;
            ctx.shadowBlur = 20;
            
            // Pulsing outer ring
            ctx.strokeStyle = theme.colors.accent + '44';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius + 8 + pulse, 0, Math.PI * 2);
            ctx.stroke();

            // Glow effect
            const gradient = ctx.createRadialGradient(
                this.x, this.y + bobY, 0,
                this.x, this.y + bobY, this.radius + 15 + pulse
            );
            gradient.addColorStop(0, theme.colors.accent);
            gradient.addColorStop(0.4, theme.colors.accent + 'AA');
            gradient.addColorStop(0.7, theme.colors.accent + '44');
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius + 15 + pulse, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Core orb with gradient
            const coreGrad = ctx.createRadialGradient(
                this.x - 4, this.y + bobY - 4, 0,
                this.x, this.y + bobY, this.radius
            );
            coreGrad.addColorStop(0, '#fff');
            coreGrad.addColorStop(0.3, theme.colors.accent);
            coreGrad.addColorStop(1, theme.colors.secondary);
            
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = coreGrad;
            ctx.fill();

            // Inner sparkle
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.8 + Math.sin(this.pulsePhase * 2) * 0.2;
            ctx.beginPath();
            ctx.arc(this.x - 4, this.y + bobY - 4, 4, 0, Math.PI * 2);
            ctx.fill();

            // Data symbol inside
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚óà', this.x, this.y + bobY + 1);
            
            ctx.restore();
        }

        isOffScreen() {
            return this.x + this.radius < 0;
        }

        getBounds() {
            return { 
                x: this.x - this.radius, 
                y: this.y - this.radius, 
                width: this.radius * 2, 
                height: this.radius * 2 
            };
        }
    }

    class PowerUp {
        constructor() {
            this.x = CONFIG.CANVAS_WIDTH + 30;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 100 - Math.random() * 80;
            this.width = 40;
            this.height = 40;
            this.collected = false;
            this.rotation = 0;
        }

        update() {
            this.x -= gameState.speed;
            this.rotation += 0.05;
        }

        draw(ctx) {
            if (this.collected) return;

            const bobY = Math.sin(Date.now() / 200) * 5;
            const pulse = Math.sin(Date.now() / 150) * 0.1 + 1;

            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2 + bobY);
            ctx.rotate(this.rotation);
            ctx.scale(pulse, pulse);
            ctx.translate(-this.width/2, -this.height/2);

            // Outer glow
            ctx.shadowColor = '#00FFD1';
            ctx.shadowBlur = 30;

            // Shield shape with better proportions
            ctx.beginPath();
            ctx.moveTo(this.width/2, 2);
            ctx.lineTo(this.width - 2, this.height * 0.25);
            ctx.lineTo(this.width - 2, this.height * 0.55);
            ctx.quadraticCurveTo(this.width/2, this.height + 5, 2, this.height * 0.55);
            ctx.lineTo(2, this.height * 0.25);
            ctx.closePath();

            // Shield gradient
            const gradient = ctx.createLinearGradient(0, 0, this.width, this.height);
            gradient.addColorStop(0, '#00FFD1');
            gradient.addColorStop(0.5, '#6C5CE7');
            gradient.addColorStop(1, '#00FFD1');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Inner shield detail
            ctx.beginPath();
            ctx.moveTo(this.width/2, 8);
            ctx.lineTo(this.width - 8, this.height * 0.28);
            ctx.lineTo(this.width - 8, this.height * 0.52);
            ctx.quadraticCurveTo(this.width/2, this.height - 3, 8, this.height * 0.52);
            ctx.lineTo(8, this.height * 0.28);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();

            // VAULT text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('VAULT', this.width/2, this.height/2 + 2);

            // Sparkles around
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 4; i++) {
                const angle = (Date.now() / 500 + i * Math.PI/2);
                const sparkX = this.width/2 + Math.cos(angle) * 28;
                const sparkY = this.height/2 + Math.sin(angle) * 28;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100 + i) * 0.5;
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        isOffScreen() {
            return this.x + this.width < 0;
        }

        getBounds() {
            return { x: this.x, y: this.y, width: this.width, height: this.height };
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10 - 3;
            this.life = 1;
            this.decay = 0.015 + Math.random() * 0.02;
            this.size = 4 + Math.random() * 6;
            this.color = color;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.3;
            this.type = Math.random() > 0.5 ? 'square' : 'circle';
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.25;
            this.vx *= 0.98;
            this.life -= this.decay;
            this.rotation += this.rotSpeed;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Glow
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = this.color;
            
            if (this.type === 'square') {
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        isDead() {
            return this.life <= 0;
        }
    }

    // Floating text for combo indicators
    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1;
            this.vy = -2;
            this.scale = 0.5;
        }

        update() {
            this.y += this.vy;
            this.vy *= 0.95;
            this.life -= 0.02;
            this.scale = Math.min(this.scale + 0.1, 1.2);
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.font = `bold ${Math.floor(18 * this.scale)}px Orbitron, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Glow effect
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 15;
            
            // Outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            
            // Fill
            ctx.fillStyle = this.color;
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }

        isDead() {
            return this.life <= 0;
        }
    }

    class BackgroundElement {
        constructor(type) {
            this.x = CONFIG.CANVAS_WIDTH;
            this.type = type;
            this.speed = 0.3 + Math.random() * 1.5;
            this.y = 40 + Math.random() * (CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 180);
            this.size = 15 + Math.random() * 35;
            this.alpha = 0.08 + Math.random() * 0.15;
            this.dataString = Math.random() > 0.5 ? '10110' : '01001';
            this.pulsePhase = Math.random() * Math.PI * 2;
        }

        update() {
            this.x -= this.speed;
            this.pulsePhase += 0.02;
        }

        draw(ctx) {
            const theme = gameState.theme;
            ctx.save();
            ctx.globalAlpha = this.alpha;
            
            switch(this.type) {
                case 'cloud':
                    // Data cloud (hexagon cluster)
                    ctx.fillStyle = theme.colors.secondary + '40';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const offsetX = i * this.size * 0.6;
                        const offsetY = (i % 2) * this.size * 0.3;
                        this.drawHexagon(ctx, this.x + offsetX, this.y + offsetY, this.size * 0.4);
                        ctx.fill();
                    }
                    break;
                case 'building':
                    // Server rack
                    ctx.fillStyle = theme.colors.secondary + '30';
                    ctx.fillRect(this.x, this.y, this.size * 0.5, this.size * 2.5);
                    // LEDs
                    const blinkPhase = Math.sin(this.pulsePhase);
                    for (let i = 0; i < 6; i++) {
                        ctx.fillStyle = blinkPhase > (i * 0.3 - 0.9) ? theme.colors.primary + '80' : theme.colors.hazard + '40';
                        ctx.beginPath();
                        ctx.arc(this.x + this.size * 0.25, this.y + 15 + i * 18, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                case 'data':
                    // Floating data stream
                    ctx.fillStyle = theme.colors.primary + '60';
                    ctx.font = `${this.size * 0.6}px monospace`;
                    const floatY = Math.sin(this.pulsePhase) * 5;
                    ctx.fillText(this.dataString, this.x, this.y + floatY);
                    break;
            }
            ctx.restore();
        }

        drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) - Math.PI / 6;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }

        isOffScreen() {
            return this.x + this.size * 2 < 0;
        }
    }

    // ==========================================
    // GAME FUNCTIONS
    // ==========================================
    function initGame() {
        resizeCanvas();
        
        // Apply difficulty settings to CONFIG
        const diff = gameState.difficultySettings;
        CONFIG.INITIAL_SPEED = diff.initialSpeed;
        CONFIG.MAX_SPEED = diff.maxSpeed;
        CONFIG.SPEED_INCREMENT = diff.speedIncrement;
        CONFIG.HAZARD_SPAWN_RATE = diff.hazardSpawnRate;
        CONFIG.ORB_SPAWN_RATE = diff.orbSpawnRate;
        CONFIG.POWERUP_SPAWN_RATE = diff.powerupSpawnRate;
        CONFIG.SHIELD_DURATION = diff.shieldDuration;
        
        gameState.player = new Player();
        gameState.score = 0;
        gameState.survivalScoreAccumulator = 0;
        gameState.speed = CONFIG.INITIAL_SPEED;
        gameState.hazards = [];
        gameState.orbs = [];
        gameState.powerups = [];
        gameState.particles = [];
        gameState.bgElements = [];
        gameState.shieldActive = false;
        gameState.waveTimer = 0;
        gameState.currentWave = null;
        gameState.isRunning = true;
        gameState.isPaused = false;
        gameState.combo = 0;
        gameState.maxCombo = 0;
        gameState.comboTimer = 0;
        gameState.multiplier = 1;
        gameState.distance = 0;
        gameState.baseScoreMultiplier = diff.scoreMultiplier;
        
        // Reset threat tracking
        gameState.threatsAvoided = 0;
        gameState.threatsAvoidedList = [];
        gameState.protectedFlash = null;
        
        // Reset learning mode state
        gameState.learningPaused = false;
        gameState.currentLearningHazard = null;
        if (gameState.learningResumeTimer) {
            clearTimeout(gameState.learningResumeTimer);
            gameState.learningResumeTimer = null;
        }
        
        // Apply learning mode speed modifier
        if (gameState.learningMode) {
            gameState.speed = CONFIG.INITIAL_SPEED * 0.5;
        }

        elements.hudScore.textContent = '0';
        elements.powerUpIndicator.classList.add('hidden');
        elements.pauseOverlay.classList.add('hidden');
        
        // Update difficulty display in HUD
        elements.hudDifficultyIcon.textContent = diff.icon;
        elements.hudDifficultyName.textContent = diff.name;

        trackEvent('game_start', { 
            industry: gameState.userData.industry,
            theme: gameState.theme.name,
            difficulty: gameState.difficulty
        });
    }

    function resizeCanvas() {
        const container = elements.gameContainer;
        const aspectRatio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
        
        let width = container.clientWidth;
        let height = container.clientHeight;
        
        if (width / height > aspectRatio) {
            width = height * aspectRatio;
        } else {
            height = width / aspectRatio;
        }
        
        elements.canvas.width = CONFIG.CANVAS_WIDTH;
        elements.canvas.height = CONFIG.CANVAS_HEIGHT;
        elements.canvas.style.width = `${width}px`;
        elements.canvas.style.height = `${height}px`;
    }

    function spawnHazard() {
        // Check minimum gap between hazards
        const minGap = gameState.difficultySettings.minHazardGap || 250;
        
        // Find the rightmost hazard (most recently spawned, closest to right edge)
        let rightmostHazardX = 0;
        for (const h of gameState.hazards) {
            if (h.x > rightmostHazardX) {
                rightmostHazardX = h.x;
            }
        }
        
        // Only spawn if there's enough gap from the last hazard
        // New hazards spawn at CONFIG.CANVAS_WIDTH + 50
        const newHazardX = CONFIG.CANVAS_WIDTH + 50;
        if (rightmostHazardX > 0 && (newHazardX - rightmostHazardX) < minGap) {
            return; // Don't spawn - too close to last hazard
        }
        
        const theme = gameState.theme;
        const type = theme.hazards[Math.floor(Math.random() * theme.hazards.length)];
        gameState.hazards.push(new Hazard(type));
    }

    function spawnOrb() {
        gameState.orbs.push(new Orb());
    }

    function spawnPowerUp() {
        gameState.powerups.push(new PowerUp());
    }

    function spawnParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            gameState.particles.push(new Particle(x, y, color));
        }
    }

    function spawnBackgroundElement() {
        const types = ['cloud', 'building', 'data'];
        gameState.bgElements.push(new BackgroundElement(types[Math.floor(Math.random() * types.length)]));
    }

    function checkCollision(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }

    function wrapText(ctx, text, maxWidth, font) {
        ctx.font = font;
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
                currentLine += ' ' + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    function triggerWave() {
        // Skip waves in learning mode to maintain educational pacing
        if (gameState.learningMode) {
            return;
        }
        
        const theme = gameState.theme;
        gameState.currentWave = theme.waves[Math.floor(Math.random() * theme.waves.length)];
        playSound('wave');
        
        // Spawn hazards based on difficulty (fewer in easier modes)
        const waveHazardCount = gameState.difficulty === 'easy' ? 1 : 
                                gameState.difficulty === 'normal' ? 2 : 3;
        const waveDelay = gameState.difficulty === 'easy' ? 1000 : 
                          gameState.difficulty === 'normal' ? 700 : 500;
        
        for (let i = 0; i < waveHazardCount; i++) {
            setTimeout(() => {
                if (gameState.isRunning && !gameState.learningPaused) spawnHazard();
            }, i * waveDelay);
        }
        
        // Clear wave after duration
        setTimeout(() => {
            gameState.currentWave = null;
        }, 3000);
    }

    // Learning mode: check for approaching hazards to trigger educational pause
    function checkLearningModeHazards() {
        if (!gameState.player) return;

        const playerX = gameState.player.x;
        
        for (const hazard of gameState.hazards) {
            // Trigger pause when hazard is 300px away and hasn't been shown yet
            const distance = hazard.x - playerX;
            if (distance > 100 && distance < 300 && !hazard.descriptionShown) {
                hazard.descriptionShown = true;
                gameState.learningPaused = true;
                gameState.currentLearningHazard = hazard;
                
                // Auto-resume after 5 seconds if player doesn't dismiss
                gameState.learningResumeTimer = setTimeout(() => {
                    if (gameState.learningPaused) {
                        gameState.learningPaused = false;
                        gameState.currentLearningHazard = null;
                    }
                }, 5000);
                
                break; // Only pause for one hazard at a time
            }
        }
    }

    // Called when player successfully jumps over a hazard
    function onHazardAvoided(hazard) {
        gameState.threatsAvoided++;
        
        // Store info about avoided threats for end screen
        if (!gameState.threatsAvoidedList.includes(hazard.type)) {
            gameState.threatsAvoidedList.push(hazard.type);
        }
        
        // Trigger protected flash effect
        gameState.protectedFlash = {
            startTime: Date.now(),
            hazardType: hazard.type
        };
        
        // Bonus points for avoiding hazard
        const bonusPoints = Math.floor(25 * (gameState.baseScoreMultiplier || 1));
        gameState.score += bonusPoints;
        elements.hudScore.textContent = gameState.score;
        
        // Spawn celebration particles
        spawnParticles(hazard.x + hazard.width/2, hazard.y, '#00FF88', 12);
        
        trackEvent('hazard_avoided', { 
            hazard_type: hazard.type,
            total_avoided: gameState.threatsAvoided
        });
    }

    function update() {
        if (!gameState.isRunning || gameState.isPaused) return;

        // Learning mode: check for hazards approaching to trigger pause
        if (gameState.learningMode && !gameState.learningPaused) {
            checkLearningModeHazards();
        }

        // If learning mode is paused, only continue rendering but don't update game state
        if (gameState.learningPaused) {
            return;
        }

        // Update player
        gameState.player.update();

        // Increase speed over time (50% slower in learning mode)
        const speedMultiplier = gameState.learningMode ? 0.5 : 1.0;
        const speedIncrement = CONFIG.SPEED_INCREMENT * speedMultiplier;
        const maxSpeed = CONFIG.MAX_SPEED * speedMultiplier;
        gameState.speed = Math.min(gameState.speed + speedIncrement, maxSpeed);

        // Spawn entities (further reduced in learning mode for educational pacing)
        const hazardSpawnRate = gameState.learningMode 
            ? CONFIG.HAZARD_SPAWN_RATE * 0.5  // 50% fewer hazards in learning mode
            : CONFIG.HAZARD_SPAWN_RATE;
        if (Math.random() < hazardSpawnRate) spawnHazard();
        if (Math.random() < CONFIG.ORB_SPAWN_RATE) spawnOrb();
        if (Math.random() < CONFIG.POWERUP_SPAWN_RATE) spawnPowerUp();
        if (Math.random() < 0.005) spawnBackgroundElement();

        // Wave system (less frequent, disabled in learning mode)
        gameState.waveTimer++;
        const waveThreshold = gameState.difficulty === 'easy' ? 1200 : 
                              gameState.difficulty === 'normal' ? 900 : 600;
        const waveProbability = gameState.difficulty === 'easy' ? 0.001 : 
                                gameState.difficulty === 'normal' ? 0.0015 : 0.002;
        if (gameState.waveTimer > waveThreshold && Math.random() < waveProbability) {
            triggerWave();
            gameState.waveTimer = 0;
        }

        // Update shield
        if (gameState.shieldActive && Date.now() > gameState.shieldEndTime) {
            gameState.shieldActive = false;
            elements.powerUpIndicator.classList.add('hidden');
        }

        // Update hazards and check for successful jumps
        gameState.hazards.forEach(h => {
            const wasAhead = h.x + h.width > gameState.player.x;
            h.update();
            const isNowBehind = h.x + h.width < gameState.player.x;
            
            // Check if player just jumped over this hazard
            if (wasAhead && isNowBehind && !h.passed) {
                h.passed = true;
                onHazardAvoided(h);
            }
        });
        gameState.hazards = gameState.hazards.filter(h => !h.isOffScreen());

        // Update orbs
        gameState.orbs.forEach(o => o.update());
        gameState.orbs = gameState.orbs.filter(o => !o.isOffScreen() && !o.collected);

        // Update powerups
        gameState.powerups.forEach(p => p.update());
        gameState.powerups = gameState.powerups.filter(p => !p.isOffScreen() && !p.collected);

        // Update particles
        gameState.particles.forEach(p => p.update());
        gameState.particles = gameState.particles.filter(p => !p.isDead());

        // Update background
        gameState.bgElements.forEach(b => b.update());
        gameState.bgElements = gameState.bgElements.filter(b => !b.isOffScreen());

        // Check collisions
        const playerBounds = gameState.player.getBounds();

        // Hazard collision
        for (const hazard of gameState.hazards) {
            if (checkCollision(playerBounds, hazard.getBounds())) {
                if (!gameState.shieldActive) {
                    gameOver();
                    return;
                } else {
                    // Destroy hazard with shield
                    spawnParticles(hazard.x, hazard.y, gameState.theme.colors.hazard, 15);
                    hazard.x = -100; // Move off screen
                }
            }
        }

        // Orb collection with combo system
        for (const orb of gameState.orbs) {
            if (!orb.collected && checkCollision(playerBounds, orb.getBounds())) {
                orb.collected = true;
                
                // Combo system
                const now = Date.now();
                if (now - gameState.lastCollectTime < 1500) {
                    gameState.combo++;
                    gameState.multiplier = Math.min(1 + gameState.combo * 0.2, 5); // Max 5x
                } else {
                    gameState.combo = 1;
                    gameState.multiplier = 1;
                }
                gameState.lastCollectTime = now;
                gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                
                const basePoints = 10 * gameState.multiplier;
                const points = Math.floor(basePoints * (gameState.baseScoreMultiplier || 1));
                gameState.score += points;
                elements.hudScore.textContent = gameState.score;
                playSound('collect');
                spawnParticles(orb.x, orb.y, gameState.theme.colors.accent, 8 + gameState.combo);
                
                // Show combo popup
                if (gameState.combo > 1) {
                    gameState.particles.push(new FloatingText(orb.x, orb.y - 20, `${gameState.combo}x COMBO!`, gameState.theme.colors.accent));
                }
            }
        }

        // Powerup collection
        for (const powerup of gameState.powerups) {
            if (!powerup.collected && checkCollision(playerBounds, powerup.getBounds())) {
                powerup.collected = true;
                activateShield();
                playSound('powerup');
                spawnParticles(powerup.x, powerup.y, '#00D4AA', 20);
            }
        }

        // Score increment for survival (affected by difficulty multiplier)
        // Use fractional accumulator to avoid always-zero score on Easy mode
        gameState.survivalScoreAccumulator = (gameState.survivalScoreAccumulator || 0) + (gameState.baseScoreMultiplier || 1);
        if (gameState.survivalScoreAccumulator >= 1) {
            const pointsToAdd = Math.floor(gameState.survivalScoreAccumulator);
            gameState.score += pointsToAdd;
            gameState.survivalScoreAccumulator -= pointsToAdd;
        }
        elements.hudScore.textContent = gameState.score;
    }

    function activateShield() {
        gameState.shieldActive = true;
        gameState.shieldEndTime = Date.now() + CONFIG.SHIELD_DURATION;
        elements.powerUpIndicator.classList.remove('hidden');
    }

    function draw() {
        const theme = gameState.theme;
        
        // Clear canvas with black background
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        // Draw background elements
        gameState.bgElements.forEach(b => b.draw(ctx));

        // Draw simple grid (perspective)
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        const gridSpacing = 60;
        const horizon = CONFIG.CANVAS_HEIGHT * 0.3;
        
        // Vertical lines
        for (let x = 0; x < CONFIG.CANVAS_WIDTH; x += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, horizon);
            ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
            ctx.stroke();
        }
        // Horizontal lines with perspective
        for (let y = horizon; y < CONFIG.CANVAS_HEIGHT; y += 30) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, y);
            ctx.stroke();
        }
        ctx.restore();

        // Draw ground
        const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(0, groundY, CONFIG.CANVAS_WIDTH, CONFIG.GROUND_HEIGHT);

        // Ground line
        ctx.save();
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, groundY);
        ctx.stroke();
        ctx.restore();

        // Draw running track lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.setLineDash([20, 40]);
        ctx.beginPath();
        ctx.moveTo(0, groundY + 20);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, groundY + 20);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw particles
        gameState.particles.forEach(p => p.draw(ctx));

        // Draw powerups
        gameState.powerups.forEach(p => p.draw(ctx));

        // Draw orbs
        gameState.orbs.forEach(o => o.draw(ctx));

        // Draw hazards
        gameState.hazards.forEach(h => h.draw(ctx));

        // Draw player
        gameState.player.draw(ctx);

        // Draw wave warning with animation
        if (gameState.currentWave) {
            ctx.save();
            const waveFlash = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 107, 107, ${waveFlash})`;
            ctx.font = 'bold 22px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#FF6B6B';
            ctx.shadowBlur = 20;
            ctx.fillText(`‚ö†Ô∏è ${gameState.currentWave.toUpperCase()} ‚ö†Ô∏è`, CONFIG.CANVAS_WIDTH / 2, 50);
            ctx.restore();
        }

        // Draw scan line effect (subtle)
        const scanY = (Date.now() / 8) % CONFIG.CANVAS_HEIGHT;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, scanY);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, scanY);
        ctx.stroke();
        ctx.restore();

        // Draw hazard preview lane at top
        drawHazardPreviewLane(ctx);

        // Draw protected flash effect
        if (gameState.protectedFlash) {
            drawProtectedFlash(ctx);
        }

        // Draw learning mode popup if active
        if (gameState.learningMode && gameState.learningPaused && gameState.currentLearningHazard) {
            drawLearningPopup(ctx);
        }

        // Draw mode indicator
        drawModeIndicator(ctx);
    }

    function drawHazardPreviewLane(ctx) {
        // Get upcoming hazards (next 3 that haven't passed yet)
        const upcomingHazards = gameState.hazards
            .filter(h => h.x > gameState.player.x + 100)
            .slice(0, 3);

        if (upcomingHazards.length === 0) return;

        ctx.save();

        // Preview lane background
        const laneY = 8;
        const laneHeight = 50;
        const laneWidth = Math.min(upcomingHazards.length * 180 + 140, CONFIG.CANVAS_WIDTH - 40);
        const laneX = CONFIG.CANVAS_WIDTH - laneWidth - 20;

        // Gradient background
        const bgGrad = ctx.createLinearGradient(laneX, laneY, laneX + laneWidth, laneY);
        bgGrad.addColorStop(0, 'rgba(20, 20, 35, 0.9)');
        bgGrad.addColorStop(1, 'rgba(30, 30, 50, 0.95)');
        ctx.fillStyle = bgGrad;
        
        ctx.beginPath();
        ctx.roundRect(laneX, laneY, laneWidth, laneHeight, 8);
        ctx.fill();

        // Border
        ctx.strokeStyle = 'rgba(255, 170, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#FFAA00';
        ctx.font = 'bold 11px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('‚ö†Ô∏è INCOMING:', laneX + 12, laneY + 18);

        // Draw each upcoming hazard preview
        upcomingHazards.forEach((hazard, index) => {
            const previewX = laneX + 100 + index * 170;
            const previewY = laneY + 8;

            // Get category color
            const catMeta = HAZARD_CATEGORIES[hazard.category] || HAZARD_CATEGORIES.data_loss;
            const color = catMeta.color;

            // Mini hazard card
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.roundRect(previewX, previewY, 160, 34, 5);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Icon
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText(hazard.icon, previewX + 18, previewY + 24);

            // Hazard name
            ctx.font = 'bold 11px Rajdhani, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(hazard.type.toUpperCase(), previewX + 36, previewY + 14);

            // Impact preview
            ctx.font = '10px Rajdhani, sans-serif';
            ctx.fillStyle = '#FFAA00';
            ctx.fillText(hazard.impact, previewX + 36, previewY + 28);
        });

        ctx.restore();
    }

    function drawProtectedFlash(ctx) {
        const flash = gameState.protectedFlash;
        const elapsed = Date.now() - flash.startTime;
        const duration = 1500;

        if (elapsed > duration) {
            gameState.protectedFlash = null;
            return;
        }

        const progress = elapsed / duration;
        const alpha = 1 - progress;
        const scale = 1 + progress * 0.5;

        ctx.save();

        // Flash effect on screen
        if (progress < 0.2) {
            ctx.fillStyle = `rgba(0, 255, 136, ${0.3 * (1 - progress * 5)})`;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }

        // "PROTECTED!" text
        ctx.font = `bold ${28 * scale}px Orbitron, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
        ctx.shadowColor = '#00FF88';
        ctx.shadowBlur = 20;
        ctx.fillText('üõ°Ô∏è PROTECTED!', CONFIG.CANVAS_WIDTH / 2, 120);

        // Vault recovery message
        if (flash.hazardType && VAULT_SOLUTIONS[flash.hazardType]) {
            const solution = VAULT_SOLUTIONS[flash.hazardType];
            ctx.font = `${14 * scale}px Rajdhani, sans-serif`;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
            ctx.shadowBlur = 10;
            ctx.fillText(`Vault Recovery: ${solution.recoveryTime}`, CONFIG.CANVAS_WIDTH / 2, 155);
        }

        ctx.restore();
    }

    function drawModeIndicator(ctx) {
        if (!gameState.learningMode) return;

        ctx.save();
        ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
        ctx.font = 'bold 11px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('üìö LEARNING MODE', 15, 25);
        ctx.restore();
    }

    function drawLearningPopup(ctx) {
        const hazard = gameState.currentLearningHazard;
        if (!hazard || !VAULT_SOLUTIONS[hazard.type]) return;

        const solution = VAULT_SOLUTIONS[hazard.type];
        const desc = HAZARD_DESCRIPTIONS[hazard.type] || '';

        ctx.save();

        // Darken background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        // Popup box
        const popupWidth = 450;
        const popupHeight = 280;
        const popupX = (CONFIG.CANVAS_WIDTH - popupWidth) / 2;
        const popupY = (CONFIG.CANVAS_HEIGHT - popupHeight) / 2 - 30;

        // Gradient background
        const bgGrad = ctx.createLinearGradient(popupX, popupY, popupX, popupY + popupHeight);
        bgGrad.addColorStop(0, 'rgba(20, 25, 40, 0.98)');
        bgGrad.addColorStop(1, 'rgba(10, 15, 30, 0.98)');
        ctx.fillStyle = bgGrad;
        
        ctx.beginPath();
        ctx.roundRect(popupX, popupY, popupWidth, popupHeight, 16);
        ctx.fill();

        // Border with category color
        const catMeta = HAZARD_CATEGORIES[hazard.category] || HAZARD_CATEGORIES.data_loss;
        ctx.strokeStyle = catMeta.color;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Header
        ctx.fillStyle = catMeta.color;
        ctx.font = 'bold 20px Orbitron, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${hazard.icon} ${hazard.type.toUpperCase()}`, CONFIG.CANVAS_WIDTH / 2, popupY + 35);

        // Impact badge
        ctx.fillStyle = '#FFAA00';
        ctx.font = 'bold 14px Rajdhani, sans-serif';
        ctx.fillText(solution.impact, CONFIG.CANVAS_WIDTH / 2, popupY + 60);

        // Separator
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(popupX + 30, popupY + 75);
        ctx.lineTo(popupX + popupWidth - 30, popupY + 75);
        ctx.stroke();

        // Description
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '14px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        const descLines = wrapText(ctx, desc, popupWidth - 60, '14px Rajdhani, sans-serif');
        descLines.forEach((line, i) => {
            ctx.fillText(line, popupX + 30, popupY + 100 + i * 20);
        });

        // Vault Solution section
        const solutionY = popupY + 100 + descLines.length * 20 + 20;
        
        ctx.fillStyle = '#00FF88';
        ctx.font = 'bold 14px Rajdhani, sans-serif';
        ctx.fillText('üõ°Ô∏è HOW VAULT PROTECTS YOU:', popupX + 30, solutionY);

        ctx.fillStyle = '#FFFFFF';
        ctx.font = '13px Rajdhani, sans-serif';
        const solutionLines = wrapText(ctx, solution.vaultSolution, popupWidth - 60, '13px Rajdhani, sans-serif');
        solutionLines.forEach((line, i) => {
            ctx.fillText(line, popupX + 30, solutionY + 22 + i * 18);
        });

        // Recovery time badge
        ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
        ctx.beginPath();
        ctx.roundRect(popupX + 30, solutionY + 22 + solutionLines.length * 18 + 10, 150, 28, 6);
        ctx.fill();
        ctx.strokeStyle = '#00FF88';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = '#00FF88';
        ctx.font = 'bold 13px Rajdhani, sans-serif';
        ctx.fillText(`‚è±Ô∏è Recovery: ${solution.recoveryTime}`, popupX + 45, solutionY + 22 + solutionLines.length * 18 + 30);

        // Continue instruction
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '12px Rajdhani, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Press SPACE or tap to continue...', CONFIG.CANVAS_WIDTH / 2, popupY + popupHeight - 20);

        ctx.restore();
    }

    function gameLoop() {
        if (!gameState.isPaused) {
            update();
            draw();
        }
        if (gameState.isRunning) {
            requestAnimationFrame(gameLoop);
        }
    }

    function gameOver() {
        gameState.isRunning = false;
        playSound('hit');
        
        const isNewHighScore = saveHighScore(gameState.score);
        gameState.highScore = loadHighScore();

        trackEvent('game_over', { 
            score: gameState.score,
            industry: gameState.userData.industry,
            difficulty: gameState.difficulty,
            is_high_score: isNewHighScore
        });

        showEndScreen(isNewHighScore);
    }

    // ==========================================
    // SCREEN MANAGEMENT
    // ==========================================
    function showRegistrationScreen() {
        const savedUser = loadUserData();
        if (savedUser) {
            elements.playerName.value = savedUser.name || '';
            elements.playerEmail.value = savedUser.email || '';
            elements.playerIndustry.value = savedUser.industry || '';
        }
        
        elements.registrationModal.classList.remove('hidden');
        elements.startModal.classList.add('hidden');
        elements.endModal.classList.add('hidden');
        elements.gameContainer.classList.add('hidden');
    }

    function showStartScreen() {
        elements.registrationModal.classList.add('hidden');
        elements.startModal.classList.remove('hidden');
        elements.endModal.classList.add('hidden');
        elements.gameContainer.classList.add('hidden');

        // Update welcome text
        elements.welcomeText.textContent = `Run, ${gameState.userData.name}!`;
        elements.industryIntro.innerHTML = `<strong>${gameState.theme.name}:</strong> ${gameState.theme.greeting}`;
        elements.highScoreValue.textContent = loadHighScore();
    }

    function showGameScreen() {
        elements.registrationModal.classList.add('hidden');
        elements.startModal.classList.add('hidden');
        elements.endModal.classList.add('hidden');
        elements.gameContainer.classList.remove('hidden');

        initGame();
        gameLoop();
    }

    function showEndScreen(isNewHighScore) {
        elements.registrationModal.classList.add('hidden');
        elements.startModal.classList.add('hidden');
        elements.endModal.classList.remove('hidden');
        elements.gameContainer.classList.add('hidden');

        const diffName = gameState.difficultySettings.name;
        const diffIcon = gameState.difficultySettings.icon;
        elements.endMessage.textContent = `${gameState.userData.name}, ${isNewHighScore ? 'New High Score!' : 'great run!'} ${diffIcon}`;
        elements.finalScore.textContent = gameState.score;

        // Check for badge (with multiple tiers)
        const badge = gameState.theme.badge;
        let earnedBadge = null;
        
        if (gameState.score >= 2000) {
            earnedBadge = { name: `${badge.icon} LEGENDARY ${badge.name}`, desc: `Legendary score of 2000+ in ${gameState.theme.name}!` };
        } else if (gameState.score >= 1000) {
            earnedBadge = { name: `${badge.icon} Elite ${badge.name}`, desc: `Elite score of 1000+ in ${gameState.theme.name}!` };
        } else if (gameState.score >= badge.threshold) {
            earnedBadge = { name: `${badge.icon} ${badge.name}`, desc: `Scored ${badge.threshold}+ in ${gameState.theme.name}!` };
        }

        if (earnedBadge) {
            elements.badgeSection.classList.remove('hidden');
            elements.badgeTitle.textContent = earnedBadge.name;
            elements.badgeDescription.textContent = earnedBadge.desc;
        } else {
            elements.badgeSection.classList.add('hidden');
        }

        // Update threats avoided section
        updateThreatsAvoidedSection();

        // Update CTA link
        const ctaUrl = `https://autorabit.com/vault-free-trial?source=recovery-runner&email=${encodeURIComponent(gameState.userData.email)}&industry=${encodeURIComponent(gameState.userData.industry)}&score=${gameState.score}&threats_avoided=${gameState.threatsAvoided}`;
        elements.ctaButton.href = ctaUrl;
    }

    function updateThreatsAvoidedSection() {
        const section = document.getElementById('threats-avoided-section');
        const countEl = document.getElementById('threats-count');
        const listEl = document.getElementById('threats-list');
        const messageEl = document.getElementById('vault-protection-message');

        if (!section || !countEl || !listEl) return;

        // Update count
        countEl.textContent = gameState.threatsAvoided;

        // Clear and populate threat badges
        listEl.innerHTML = '';

        if (gameState.threatsAvoidedList.length === 0) {
            listEl.innerHTML = '<span style="color: var(--text-muted); font-size: 0.85rem;">No threats encountered yet - try again!</span>';
        } else {
            // Show up to 6 unique threat types
            gameState.threatsAvoidedList.slice(0, 6).forEach(threatType => {
                const solution = VAULT_SOLUTIONS[threatType];
                if (solution) {
                    const badge = document.createElement('div');
                    badge.style.cssText = 'background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 20px; padding: 6px 12px; font-size: 0.8rem; display: flex; align-items: center; gap: 5px;';
                    badge.innerHTML = `<span>${solution.icon}</span><span>${threatType}</span>`;
                    listEl.appendChild(badge);
                }
            });

            // Show "+X more" if there are more types
            if (gameState.threatsAvoidedList.length > 6) {
                const more = document.createElement('div');
                more.style.cssText = 'background: rgba(255,255,255,0.05); border-radius: 20px; padding: 6px 12px; font-size: 0.8rem; color: var(--text-muted);';
                more.textContent = `+${gameState.threatsAvoidedList.length - 6} more`;
                listEl.appendChild(more);
            }
        }

        // Update protection message based on count
        if (messageEl) {
            if (gameState.threatsAvoided === 0) {
                messageEl.textContent = 'Data disasters can strike at any time. Vault ensures instant recovery.';
            } else if (gameState.threatsAvoided < 5) {
                messageEl.textContent = `You avoided ${gameState.threatsAvoided} threat${gameState.threatsAvoided > 1 ? 's' : ''}! With Vault, recovery takes minutes, not weeks.`;
            } else if (gameState.threatsAvoided < 15) {
                messageEl.textContent = `Impressive! ${gameState.threatsAvoided} threats neutralized. Vault provides this protection 24/7 for your real data.`;
            } else {
                messageEl.textContent = `üèÜ ${gameState.threatsAvoided} threats defeated! You're a data protection champion. Imagine this protection for your Salesforce org.`;
            }
        }
    }

    // ==========================================
    // EVENT HANDLERS
    // ==========================================
    elements.registrationForm.addEventListener('submit', (e) => {
        e.preventDefault();

        let isValid = true;

        // Validate name
        if (!elements.playerName.value.trim()) {
            elements.nameError.classList.add('show');
            isValid = false;
        } else {
            elements.nameError.classList.remove('show');
        }

        // Validate email
        if (!validateEmail(elements.playerEmail.value)) {
            elements.emailError.classList.add('show');
            isValid = false;
        } else {
            elements.emailError.classList.remove('show');
        }

        if (!isValid) return;

        // Save user data
        gameState.userData = {
            name: elements.playerName.value.trim(),
            email: elements.playerEmail.value.trim(),
            industry: elements.playerIndustry.value || 'other'
        };

        saveUserData(gameState.userData);

        // Set theme based on industry
        gameState.theme = THEMES[gameState.userData.industry] || THEMES.other;

        initAudio();
        showStartScreen();
    });

    elements.startGameBtn.addEventListener('click', () => {
        showGameScreen();
    });

    // Difficulty selection
    elements.difficultyOptions.addEventListener('click', (e) => {
        const option = e.target.closest('.difficulty-option');
        if (!option) return;
        
        // Remove selected class from all options
        elements.difficultyOptions.querySelectorAll('.difficulty-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        
        // Add selected class to clicked option
        option.classList.add('selected');
        
        // Update game state with selected difficulty
        const difficulty = option.dataset.difficulty;
        gameState.difficulty = difficulty;
        gameState.difficultySettings = DIFFICULTY_PRESETS[difficulty];
        
        // Save preference
        try {
            localStorage.setItem('recoveryRunner_difficulty', difficulty);
        } catch (e) {
            console.warn('Could not save difficulty preference:', e);
        }
        
        trackEvent('difficulty_selected', { difficulty: difficulty });
    });

    // Load saved difficulty preference
    function loadDifficultyPreference() {
        try {
            const saved = localStorage.getItem('recoveryRunner_difficulty');
            if (saved && DIFFICULTY_PRESETS[saved]) {
                gameState.difficulty = saved;
                gameState.difficultySettings = DIFFICULTY_PRESETS[saved];
                
                // Update UI
                elements.difficultyOptions.querySelectorAll('.difficulty-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.difficulty === saved);
                });
            }
        } catch (e) {
            console.warn('Could not load difficulty preference:', e);
        }
    }

    // Mode toggle selection (Arcade vs Learning)
    function setupModeToggle() {
        const arcadeBtn = elements.arcadeModeBtn;
        const learningBtn = elements.learningModeBtn;
        const modeDesc = elements.modeDescription;

        if (!arcadeBtn || !learningBtn) return;

        arcadeBtn.addEventListener('click', () => {
            gameState.learningMode = false;
            arcadeBtn.style.borderColor = 'var(--primary)';
            arcadeBtn.style.background = 'rgba(108, 92, 231, 0.2)';
            arcadeBtn.classList.add('selected');
            learningBtn.style.borderColor = 'rgba(255,255,255,0.2)';
            learningBtn.style.background = 'rgba(100, 200, 255, 0.1)';
            learningBtn.classList.remove('selected');
            if (modeDesc) {
                modeDesc.innerHTML = 'üéÆ <strong>Arcade:</strong> Fast-paced action with hazard previews at the top of the screen';
            }
            trackEvent('mode_selected', { mode: 'arcade' });
        });

        learningBtn.addEventListener('click', () => {
            gameState.learningMode = true;
            learningBtn.style.borderColor = '#64C8FF';
            learningBtn.style.background = 'rgba(100, 200, 255, 0.2)';
            learningBtn.classList.add('selected');
            arcadeBtn.style.borderColor = 'rgba(255,255,255,0.2)';
            arcadeBtn.style.background = 'rgba(108, 92, 231, 0.1)';
            arcadeBtn.classList.remove('selected');
            if (modeDesc) {
                modeDesc.innerHTML = 'üìö <strong>Learning:</strong> 50% slower speed with auto-pause to learn about each threat and how Vault protects you';
            }
            trackEvent('mode_selected', { mode: 'learning' });
        });
    }

    // Load saved mode preference
    function loadModePreference() {
        try {
            const saved = localStorage.getItem('recoveryRunner_mode');
            if (saved === 'learning') {
                gameState.learningMode = true;
                if (elements.learningModeBtn) {
                    elements.learningModeBtn.click();
                }
            }
        } catch (e) {
            console.warn('Could not load mode preference:', e);
        }
    }

    elements.playAgainBtn.addEventListener('click', () => {
        showStartScreen();
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        if (!gameState.isRunning) return;

        switch(e.code) {
            case 'Space':
            case 'ArrowUp':
                e.preventDefault();
                // Handle learning mode popup dismissal
                if (gameState.learningPaused && gameState.currentLearningHazard) {
                    resumeFromLearningPause();
                    return;
                }
                if (!gameState.isPaused) {
                    gameState.player.jump();
                }
                break;
            case 'KeyP':
                togglePause();
                break;
            case 'KeyM':
                toggleSound();
                break;
        }
    });

    // Touch controls
    elements.canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Handle learning mode popup dismissal
        if (gameState.learningPaused && gameState.currentLearningHazard) {
            resumeFromLearningPause();
            return;
        }
        if (gameState.isRunning && !gameState.isPaused) {
            gameState.player.jump();
        }
    });

    elements.mobileJump.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Handle learning mode popup dismissal
        if (gameState.learningPaused && gameState.currentLearningHazard) {
            resumeFromLearningPause();
            return;
        }
        if (gameState.isRunning && !gameState.isPaused) {
            gameState.player.jump();
        }
    });

    // Resume from learning mode pause
    function resumeFromLearningPause() {
        gameState.learningPaused = false;
        gameState.currentLearningHazard = null;
        if (gameState.learningResumeTimer) {
            clearTimeout(gameState.learningResumeTimer);
            gameState.learningResumeTimer = null;
        }
    }

    // HUD buttons
    elements.pauseBtn.addEventListener('click', togglePause);
    elements.muteBtn.addEventListener('click', toggleSound);
    elements.resumeBtn.addEventListener('click', togglePause);

    function togglePause() {
        if (!gameState.isRunning) return;
        gameState.isPaused = !gameState.isPaused;
        elements.pauseOverlay.classList.toggle('hidden', !gameState.isPaused);
        // Note: Don't call gameLoop() here - the existing loop continues running
        // and will automatically resume updating when isPaused becomes false
    }

    function toggleSound() {
        gameState.soundEnabled = !gameState.soundEnabled;
        elements.muteBtn.textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
    }

    // Share buttons with viral hooks
    elements.shareX.addEventListener('click', () => {
        const gameUrl = window.location.href;
        const badge = gameState.score >= 1000 ? 'üèÜ ELITE ' : gameState.score >= 500 ? 'üõ°Ô∏è ' : 'üéÆ ';
        const diffText = gameState.difficultySettings.name !== 'Normal' ? ` on ${gameState.difficultySettings.name} mode ${gameState.difficultySettings.icon}` : '';
        const text = `${badge}Just scored ${gameState.score} in Recovery Runner${diffText}!\n\nüî• Can YOU survive Salesforce data disasters?\n\nPlay now: ${gameUrl}\n\n#Salesforce #DataBackup #RecoveryRunner @AutoRABIT`;
        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
        trackEvent('share_x', { score: gameState.score, difficulty: gameState.difficulty });
    });

    elements.shareLinkedIn.addEventListener('click', () => {
        const gameUrl = window.location.href;
        const badge = gameState.score >= 1000 ? 'Elite ' : gameState.score >= 500 ? 'Pro ' : '';
        window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(gameUrl)}`, '_blank');
        trackEvent('share_linkedin', { score: gameState.score });
    });

    elements.emailResults.addEventListener('click', () => {
        const badge = gameState.score >= 1000 ? 'üèÜ LEGENDARY' : gameState.score >= 500 ? 'üõ°Ô∏è PRO' : 'üéÆ';
        const diffInfo = gameState.difficultySettings;
        const subject = `${badge} Recovery Runner Score: ${gameState.score}! (${diffInfo.name} Mode)`;
        const body = `Hey!\n\n` +
            `I just scored ${gameState.score} points in Recovery Runner - an addictive game about surviving Salesforce data disasters!\n\n` +
            `üéÆ My Stats:\n` +
            `‚Ä¢ Score: ${gameState.score}\n` +
            `‚Ä¢ Difficulty: ${diffInfo.icon} ${diffInfo.name} (${diffInfo.scoreMultiplier}√ó multiplier)\n` +
            `‚Ä¢ Theme: ${gameState.theme.name}\n` +
            `‚Ä¢ Badge: ${gameState.theme.badge.icon} ${gameState.theme.badge.name}\n\n` +
            `üïπÔ∏è Play here: ${window.location.href}\n\n` +
            `This game actually teaches you real stuff about data protection. Pretty clever marketing from AutoRABIT!\n\n` +
            `üõ°Ô∏è Want real Salesforce backup? Check out Vault:\n` +
            `https://autorabit.com/vault-free-trial?source=recovery-runner&email=${encodeURIComponent(gameState.userData.email)}&industry=${encodeURIComponent(gameState.userData.industry)}`;
        window.location.href = `mailto:${gameState.userData.email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        trackEvent('email_results', { score: gameState.score, difficulty: gameState.difficulty });
    });

    elements.ctaButton.addEventListener('click', () => {
        trackEvent('cta_click', { 
            score: gameState.score,
            industry: gameState.userData.industry
        });
    });

    // Email to Friend handlers
    elements.emailFriend.addEventListener('click', () => {
        elements.friendModal.classList.remove('hidden');
        elements.friendEmail.value = '';
        elements.friendEmail.focus();
    });

    elements.friendCancel.addEventListener('click', () => {
        elements.friendModal.classList.add('hidden');
    });

    elements.friendSend.addEventListener('click', () => {
        const friendEmail = elements.friendEmail.value.trim();
        if (!validateEmail(friendEmail)) {
            elements.friendEmail.style.borderColor = 'var(--danger)';
            setTimeout(() => {
                elements.friendEmail.style.borderColor = '';
            }, 2000);
            return;
        }

        const subject = `${gameState.userData.name} challenges you to Recovery Runner!`;
        const body = `Hey!\n\n${gameState.userData.name} just scored ${gameState.score} points in Recovery Runner and thinks you can't beat it!\n\n` +
            `üéÆ Play now: ${window.location.href}\n\n` +
            `Recovery Runner is a game that teaches you about Salesforce data risks‚Äîcan you survive the data disasters?\n\n` +
            `Ready to protect your real Salesforce data? Try AutoRABIT Vault:\n` +
            `https://autorabit.com/vault-free-trial?source=recovery-runner-challenge`;
        
        window.location.href = `mailto:${friendEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        elements.friendModal.classList.add('hidden');
        trackEvent('email_friend', { score: gameState.score });
    });

    // Close friend modal on background click
    elements.friendModal.addEventListener('click', (e) => {
        if (e.target === elements.friendModal) {
            elements.friendModal.classList.add('hidden');
        }
    });

    // Window resize
    window.addEventListener('resize', resizeCanvas);

    // ==========================================
    // INITIALIZE
    // ==========================================
    loadDifficultyPreference();
    setupModeToggle();
    loadModePreference();
    showRegistrationScreen();

    </script>
</body>
</html>

