<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Recovery Runner - AutoRABIT Vault</title>
    <meta name="description" content="Run through data disasters and learn how AutoRABIT Vault protects your Salesforce data!">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Firebase SDK for global leaderboard -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
    <style>
        /* ==========================================
           ROOT VARIABLES & RESET
           ========================================== */
        :root {
            --primary: #00D4FF;
            --primary-dark: #0099CC;
            --secondary: #FF6B9D;
            --accent: #FFD93D;
            --danger: #FF4757;
            --warning: #FFAA00;
            --success: #00FF88;
            --bg-dark: #1A1A2E;
            --bg-medium: #16213E;
            --bg-gradient: #0F0F23;
            --text-light: #FFFFFF;
            --text-muted: #B8C5D6;
            --glass: rgba(0, 212, 255, 0.1);
            --glass-border: rgba(0, 212, 255, 0.3);
            --neon-glow: 0 0 15px rgba(0, 212, 255, 0.5);
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Rajdhani', sans-serif;
            --font-mono: 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-light);
        }

        h1, h2, h3, h4, .game-title, .score-value {
            font-family: var(--font-display);
        }

        /* ==========================================
           ANIMATIONS
           ========================================== */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); }
            92% { transform: translate(-2px, 2px); }
            94% { transform: translate(2px, -2px); }
            96% { transform: translate(-2px, -2px); }
            98% { transform: translate(2px, 2px); }
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes shieldPulse {
            0%, 100% { box-shadow: 0 0 20px var(--primary), inset 0 0 20px rgba(0, 212, 170, 0.3); }
            50% { box-shadow: 0 0 40px var(--primary), inset 0 0 40px rgba(0, 212, 170, 0.5); }
        }

        /* ==========================================
           GAME CONTAINER & CANVAS
           ========================================== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1A1A2E 0%, #0F0F23 50%, #16213E 100%);
        }

        #game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes nebula {
            0% { opacity: 0.8; }
            100% { opacity: 1; transform: scale(1.05); }
        }

        #gameCanvas {
            display: block;
            background: transparent;
            max-width: 100%;
            max-height: 100%;
            border-radius: 12px;
            border: 2px solid var(--glass-border);
            box-shadow: var(--neon-glow), inset 0 0 60px rgba(108, 92, 231, 0.1);
        }

        /* ==========================================
           MODAL OVERLAY
           ========================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(15, 15, 35, 0.98) 100%);
            pointer-events: none;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: linear-gradient(145deg, #1A1A2E 0%, #16213E 100%);
            border: 2px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.8);
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #FFFFFF;
            border-radius: 24px 24px 0 0;
        }

        /* ==========================================
           LOGO & BRANDING
           ========================================== */
        .logo-container {
            text-align: center;
            margin-bottom: 35px;
        }

        .logo-icon {
            width: 90px;
            height: 90px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            animation: iconFloat 4s ease-in-out infinite, iconGlow 2s ease-in-out infinite alternate;
            box-shadow: 0 15px 50px rgba(0, 255, 209, 0.4), inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        @keyframes iconFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(3deg); }
        }

        @keyframes iconGlow {
            0% { box-shadow: 0 15px 50px rgba(0, 255, 209, 0.4), inset 0 -5px 20px rgba(0, 0, 0, 0.3); }
            100% { box-shadow: 0 20px 60px rgba(0, 255, 209, 0.6), inset 0 -5px 20px rgba(0, 0, 0, 0.3), 0 0 30px rgba(108, 92, 231, 0.3); }
        }

        .game-title {
            font-size: 2.2rem;
            font-weight: 900;
            color: #FFFFFF;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            letter-spacing: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }

        /* ==========================================
           FORM STYLES
           ========================================== */
        .form-group {
            margin-bottom: 22px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 700;
            color: var(--primary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 16px 20px;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid rgba(0, 255, 209, 0.2);
            border-radius: 14px;
            color: var(--text-light);
            font-size: 1rem;
            font-family: var(--font-body);
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 255, 209, 0.25), inset 0 0 20px rgba(0, 255, 209, 0.05);
            background: rgba(108, 92, 231, 0.15);
        }

        .form-group input::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }

        .form-group select option {
            background: var(--bg-dark);
            color: var(--text-light);
            padding: 10px;
        }

        .form-error {
            color: var(--danger);
            font-size: 0.8rem;
            margin-top: 8px;
            display: none;
            font-weight: 600;
        }

        .form-error.show {
            display: block;
            animation: shakeError 0.4s ease-out;
        }

        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* ==========================================
           BUTTONS
           ========================================== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 18px 36px;
            border: none;
            border-radius: 14px;
            font-size: 1rem;
            font-weight: 700;
            font-family: var(--font-display);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--bg-dark);
            box-shadow: 0 10px 40px rgba(0, 255, 209, 0.4), inset 0 1px 0 rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .btn-primary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 50px rgba(0, 255, 209, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .btn-primary:active {
            transform: translateY(-1px) scale(0.99);
        }

        .btn-secondary {
            background: rgba(0, 212, 255, 0.15);
            border: 2px solid var(--glass-border);
            color: var(--text-light);
        }

        .btn-secondary:hover {
            background: rgba(0, 212, 255, 0.25);
            border-color: var(--primary);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        .btn-cta {
            background: linear-gradient(135deg, var(--accent) 0%, #E84393 100%);
            color: white;
            box-shadow: 0 10px 40px rgba(253, 121, 168, 0.4);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .btn-cta:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 50px rgba(253, 121, 168, 0.5);
        }

        .btn-social {
            padding: 14px 22px;
            font-size: 0.8rem;
            flex: 1;
            letter-spacing: 1px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-full {
            width: 100%;
        }

        /* ==========================================
           START SCREEN
           ========================================== */
        .start-screen {
            text-align: center;
        }

        .welcome-text {
            font-size: 1.5rem;
            margin-bottom: 10px;
            animation: slideIn 0.5s ease-out;
        }

        .industry-intro {
            color: var(--text-muted);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .industry-intro strong {
            color: var(--primary);
        }

        .game-instructions {
            background: var(--glass);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: left;
        }

        .game-instructions h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .game-instructions ul {
            list-style: none;
            padding: 0;
        }

        .game-instructions li {
            padding: 8px 0;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-instructions li::before {
            content: '‚ñ∏';
            color: var(--primary);
        }

        .high-score-display {
            background: linear-gradient(135deg, rgba(0, 212, 170, 0.1) 0%, rgba(0, 212, 170, 0.05) 100%);
            border: 1px solid rgba(0, 212, 170, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .high-score-display span {
            color: var(--primary);
            font-size: 1.5rem;
            font-weight: 800;
        }

        /* ==========================================
           DIFFICULTY SELECTOR
           ========================================== */
        .difficulty-section {
            margin-bottom: 25px;
        }

        .difficulty-section h3 {
            color: var(--primary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 15px;
            font-family: var(--font-display);
        }

        .difficulty-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .difficulty-option {
            position: relative;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid rgba(0, 255, 209, 0.2);
            border-radius: 14px;
            padding: 16px 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }

        .difficulty-option:hover {
            border-color: var(--primary);
            background: rgba(108, 92, 231, 0.15);
            transform: translateY(-2px);
        }

        .difficulty-option.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.15) 0%, rgba(108, 92, 231, 0.15) 100%);
            box-shadow: 0 0 25px rgba(0, 255, 209, 0.2), inset 0 0 20px rgba(0, 255, 209, 0.05);
        }

        .difficulty-option.selected::before {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 10px;
            color: var(--primary);
            font-weight: bold;
            font-size: 0.9rem;
        }

        .difficulty-icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
            display: block;
        }

        .difficulty-name {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .difficulty-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .difficulty-multiplier {
            display: inline-block;
            margin-top: 8px;
            padding: 3px 10px;
            background: rgba(0, 255, 209, 0.15);
            border-radius: 20px;
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--primary);
            font-family: var(--font-display);
            letter-spacing: 0.5px;
        }

        .difficulty-option.selected .difficulty-multiplier {
            background: var(--primary);
            color: var(--bg-dark);
        }

        /* Speed indicator badge */
        .speed-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-top: 5px;
        }

        .speed-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
            opacity: 0.3;
        }

        .speed-dot.active {
            background: var(--primary);
            opacity: 1;
            box-shadow: 0 0 6px var(--primary);
        }

        /* Current difficulty display in HUD */
        .hud-difficulty {
            font-size: 0.75rem;
            padding: 8px 14px;
            background: rgba(108, 92, 231, 0.2);
            border-radius: 8px;
            margin-top: 8px;
        }

        .hud-difficulty span {
            color: var(--warning);
            font-weight: 700;
        }

        @media (max-width: 480px) {
            .difficulty-options {
                grid-template-columns: 1fr;
            }
            
            .difficulty-option {
                padding: 14px 12px;
            }

            .difficulty-icon {
                font-size: 1.5rem;
            }
        }

        /* ==========================================
           END SCREEN
           ========================================== */
        .end-screen {
            text-align: center;
        }

        .score-display {
            margin: 35px 0;
            position: relative;
        }

        .score-display::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(0, 255, 209, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: scorePulse 2s ease-in-out infinite;
        }

        @keyframes scorePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }

        .score-value {
            font-size: 5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            text-shadow: 0 0 60px rgba(0, 255, 209, 0.5);
            animation: scoreReveal 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes scoreReveal {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .score-label {
            color: var(--text-muted);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 600;
        }

        .badge-earned {
            border-radius: 16px;
            padding: 20px;
            margin: 25px 0;
            animation: badgeReveal 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }
        
        /* Expert tier - Gold */
        .badge-earned[data-tier="expert"] {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%);
            animation: badgeReveal 0.6s cubic-bezier(0.16, 1, 0.3, 1), expertShine 2s ease-in-out infinite;
        }
        
        /* Pro tier - Silver/Blue */
        .badge-earned[data-tier="pro"] {
            background: linear-gradient(135deg, #00D4FF 0%, #0099CC 50%, #006699 100%);
            animation: badgeReveal 0.6s cubic-bezier(0.16, 1, 0.3, 1), proShine 2.5s ease-in-out infinite;
        }
        
        /* Intern tier - Subtle encouragement */
        .badge-earned[data-tier="intern"] {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.3) 0%, rgba(0, 212, 255, 0.2) 100%);
            border: 2px dashed rgba(0, 212, 255, 0.5);
        }

        @keyframes badgeReveal {
            from { transform: scale(0) rotate(-10deg); opacity: 0; }
            to { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes expertShine {
            0%, 100% { box-shadow: 0 5px 30px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 10px 50px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 140, 0, 0.5); }
        }
        
        @keyframes proShine {
            0%, 100% { box-shadow: 0 5px 30px rgba(0, 212, 255, 0.4); }
            50% { box-shadow: 0 10px 50px rgba(0, 212, 255, 0.6), 0 0 20px rgba(0, 153, 204, 0.4); }
        }

        .badge-earned::before {
            content: '‚òÖ';
            position: absolute;
            font-size: 80px;
            right: -10px;
            top: -20px;
            opacity: 0.2;
        }
        
        .badge-earned[data-tier="intern"]::before {
            content: 'üìö';
            font-size: 60px;
        }
        
        .badge-earned[data-tier="expert"]::before {
            content: 'üèÜ';
        }

        .badge-earned.hidden {
            display: none;
        }

        .badge-earned h4 {
            color: var(--bg-dark);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .badge-earned[data-tier="intern"] h4 {
            color: var(--text-light);
        }

        .badge-earned p {
            color: rgba(0, 0, 0, 0.7);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .badge-earned[data-tier="intern"] p {
            color: var(--text-muted);
        }

        .vault-tip {
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.1) 0%, rgba(108, 92, 231, 0.1) 100%);
            border-left: 4px solid var(--primary);
            padding: 18px 20px;
            margin: 25px 0;
            text-align: left;
            border-radius: 0 14px 14px 0;
            position: relative;
        }

        .vault-tip::before {
            content: 'üí°';
            position: absolute;
            left: -18px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            background: var(--bg-medium);
            padding: 5px;
            border-radius: 50%;
        }

        .vault-tip strong {
            color: var(--primary);
            font-weight: 700;
        }

        .share-section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(108, 92, 231, 0.1);
            border-radius: 16px;
            border: 1px solid rgba(0, 255, 209, 0.1);
        }

        .share-section h4 {
            color: var(--text-light);
            margin-bottom: 18px;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .share-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-x { 
            background: linear-gradient(135deg, #14171A 0%, #000 100%); 
            color: #fff;
            border: 1px solid #333;
        }
        .btn-linkedin { 
            background: linear-gradient(135deg, #0A66C2 0%, #004182 100%); 
            color: #fff; 
        }
        .btn-email { 
            background: linear-gradient(135deg, var(--secondary) 0%, #5B4CC4 100%); 
            color: #fff; 
        }
        .btn-friend {
            background: linear-gradient(135deg, var(--accent) 0%, #E84393 100%);
            color: #fff;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 25px;
        }

        /* Friend Email Modal */
        .friend-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 2, 33, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .friend-modal.hidden {
            display: none;
        }

        .friend-modal-content {
            background: var(--bg-medium);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .friend-modal-content h3 {
            color: var(--primary);
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .friend-modal-content input {
            width: 100%;
            padding: 14px 18px;
            margin-bottom: 15px;
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-light);
            font-family: var(--font-body);
            font-size: 1rem;
        }

        .friend-modal-content input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .friend-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .friend-modal-buttons .btn {
            flex: 1;
            padding: 12px;
            font-size: 0.85rem;
        }

        /* ==========================================
           HUD (Heads Up Display)
           ========================================== */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }

        .hud-item {
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid var(--glass-border);
            border-radius: 14px;
            padding: 14px 22px;
            pointer-events: auto;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 212, 255, 0.1);
        }

        .hud-score {
            font-size: 1.3rem;
            font-weight: 700;
            font-family: var(--font-display);
            letter-spacing: 1px;
        }

        .hud-score span {
            color: var(--primary);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .hud-lives {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .hud-lives .heart {
            font-size: 1.4rem;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 8px rgba(255, 71, 87, 0.6));
        }

        .hud-lives .heart.active {
            animation: heartPulse 1.5s ease-in-out infinite;
        }

        .hud-lives .heart.lost {
            filter: grayscale(100%) opacity(0.3);
            animation: heartLost 0.5s ease-out;
        }

        .hud-lives .heart.damage {
            animation: heartDamage 0.5s ease-out;
        }

        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes heartLost {
            0% { transform: scale(1.5); filter: brightness(2); }
            100% { transform: scale(1); filter: grayscale(100%) opacity(0.3); }
        }

        @keyframes heartDamage {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.3) rotate(-10deg); }
            50% { transform: scale(0.8) rotate(10deg); }
            75% { transform: scale(1.2) rotate(-5deg); }
        }

        .hud-controls {
            display: flex;
            gap: 10px;
        }

        .hud-btn {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid var(--glass-border);
            border-radius: 10px;
            padding: 10px 15px;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-family: var(--font-body);
            font-weight: 600;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
        }

        .hud-btn:hover {
            background: rgba(0, 255, 209, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 255, 209, 0.3);
        }

        .power-up-indicator {
            position: absolute;
            top: 85px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--bg-dark);
            padding: 12px 30px;
            border-radius: 30px;
            font-weight: 900;
            font-family: var(--font-display);
            letter-spacing: 2px;
            animation: shieldActive 0.5s ease-in-out infinite alternate;
            z-index: 100;
            box-shadow: var(--neon-glow);
            border: 2px solid rgba(255,255,255,0.3);
        }

        @keyframes shieldActive {
            0% { transform: translateX(-50%) scale(1); box-shadow: var(--neon-glow); }
            100% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 40px rgba(0, 255, 209, 0.7), 0 0 80px rgba(0, 255, 209, 0.4); }
        }

        .power-up-indicator.hidden {
            display: none;
        }

        /* ==========================================
           PAUSE OVERLAY
           ========================================== */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .pause-overlay.hidden {
            display: none;
        }

        .pause-content {
            text-align: center;
        }

        .pause-content h2 {
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 20px;
        }

        /* ==========================================
           MOBILE CONTROLS
           ========================================== */
        .mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: none;
            justify-content: center;
            gap: 25px;
            z-index: 100;
        }

        .mobile-btn {
            width: 85px;
            height: 85px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.2) 0%, rgba(108, 92, 231, 0.2) 100%);
            border: 3px solid var(--primary);
            color: var(--primary);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 0 30px rgba(0, 255, 209, 0.3), inset 0 0 30px rgba(0, 255, 209, 0.1);
            transition: all 0.2s ease;
        }

        .mobile-btn:active {
            background: linear-gradient(135deg, rgba(0, 255, 209, 0.5) 0%, rgba(108, 92, 231, 0.5) 100%);
            transform: scale(0.92);
            box-shadow: 0 0 50px rgba(0, 255, 209, 0.5), inset 0 0 50px rgba(0, 255, 209, 0.2);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }

        /* Wave Warning Banner */
        .wave-banner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.3), transparent);
            padding: 8px;
            text-align: center;
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--danger);
            letter-spacing: 2px;
            animation: waveBanner 0.3s ease-in-out infinite alternate;
            z-index: 50;
        }

        @keyframes waveBanner {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .wave-banner.hidden {
            display: none;
        }

        /* ==========================================
           RESPONSIVE
           ========================================== */
        @media (max-width: 600px) {
            .modal {
                padding: 25px;
                margin: 10px;
            }

            .game-title {
                font-size: 1.6rem;
            }

            .score-value {
                font-size: 3rem;
            }

            .btn {
                padding: 14px 24px;
                font-size: 0.9rem;
            }

            .share-buttons {
                flex-direction: column;
            }

            .btn-social {
                width: 100%;
            }

            .hud {
                flex-direction: column;
                gap: 10px;
            }
        }

        /* Desktop optimizations for wider modals */
        @media (min-width: 768px) {
            .modal {
                padding: 50px;
            }

            .difficulty-options {
                grid-template-columns: repeat(2, 1fr);
            }

            .mode-toggle {
                flex-direction: row;
            }

            .share-buttons {
                flex-wrap: nowrap;
                justify-content: center;
            }

            .btn-social {
                flex: 1;
                max-width: 200px;
            }

            .game-instructions {
                padding: 25px 30px;
            }

            .threats-avoided-section {
                padding: 25px;
            }

            .leaderboard-section {
                padding: 25px;
            }

            .share-info-section {
                padding: 25px;
            }

            .action-buttons {
                flex-direction: row;
                justify-content: center;
            }

            .action-buttons .btn {
                flex: 1;
                max-width: 250px;
            }
        }

        /* ==========================================
           ACCESSIBILITY
           ========================================== */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        *:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* ==========================================
           LEADERBOARD STYLES
           ========================================== */
        .leaderboard-section {
            background: rgba(108, 92, 231, 0.1);
            border: 2px solid rgba(108, 92, 231, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .leaderboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .leaderboard-tab {
            flex: 1;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: var(--font-body);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .leaderboard-tab:hover {
            border-color: var(--primary);
            color: var(--text-light);
        }

        .leaderboard-tab.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--primary);
            color: var(--primary);
        }

        .leaderboard-content {
            max-height: 300px;
            overflow-y: auto;
        }

        .leaderboard-loading {
            text-align: center;
            color: var(--text-muted);
            padding: 20px;
        }

        .leaderboard-empty {
            text-align: center;
            color: var(--text-muted);
            padding: 20px;
            font-style: italic;
        }

        .leaderboard-entry {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        .leaderboard-entry.highlight {
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .leaderboard-rank {
            width: 35px;
            font-size: 1.2rem;
            text-align: center;
            flex-shrink: 0;
        }

        .leaderboard-info {
            flex: 1;
            min-width: 0;
            margin-left: 10px;
        }

        .leaderboard-name {
            font-weight: 600;
            color: var(--text-light);
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .leaderboard-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            gap: 10px;
            margin-top: 2px;
        }

        .leaderboard-score {
            font-weight: 700;
            color: var(--accent);
            font-size: 1.1rem;
            flex-shrink: 0;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <!-- Start Screen Modal -->
    <div id="start-modal" class="modal-overlay" role="dialog" aria-labelledby="start-title" aria-modal="true">
        <div class="modal start-screen">
            <div class="logo-container">
                <div class="logo-icon" aria-hidden="true">üèÉ</div>
                <h1 id="start-title" class="game-title">Ready to Run?</h1>
            </div>
            
            <p class="industry-intro" id="industry-intro" style="font-size: 1.1rem; line-height: 1.6; margin: 20px 0;">
                <strong>Your Mission:</strong> Jump over data disasters that threaten your business. Each hazard represents a real risk that can cost your company thousands in fines, lost revenue, and reputation damage. Learn what these threats mean for your business as you play!
            </p>
            
            <div class="high-score-display" id="high-score-section">
                <p>üèÜ Your Best Score: <span id="high-score-value">0</span></p>
            </div>

            <!-- Streak Display -->
            <div class="streak-display" id="streak-section" style="display: none; background: linear-gradient(135deg, rgba(255, 165, 0, 0.15), rgba(255, 100, 0, 0.08)); border: 2px solid rgba(255, 165, 0, 0.4); border-radius: 12px; padding: 15px; margin-bottom: 20px; text-align: center;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 1.8rem;">üî•</span>
                    <div>
                        <div style="font-size: 1.4rem; font-weight: bold; color: #FFA500;">
                            <span id="streak-count">0</span> Day Streak!
                        </div>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">
                            +<span id="streak-bonus">0</span>% Score Bonus Active
                        </div>
                    </div>
                </div>
            </div>

            <!-- Team Code Section -->
            <div class="team-code-section" style="background: rgba(108, 92, 231, 0.1); border: 1px solid rgba(108, 92, 231, 0.3); border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="flex: 1;">
                        <label style="font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 5px;">üë• Team Code (optional)</label>
                        <input type="text" id="team-code-input" placeholder="Enter code or create one" maxlength="6" style="width: 100%; padding: 10px 12px; background: rgba(108, 92, 231, 0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--text-light); font-size: 0.9rem; font-family: var(--font-mono); text-transform: uppercase; letter-spacing: 2px;">
                    </div>
                    <button id="generate-team-code" style="padding: 10px 15px; background: var(--primary); border: none; border-radius: 8px; color: white; font-size: 0.8rem; cursor: pointer; white-space: nowrap; margin-top: 18px;">
                        Generate
                    </button>
                </div>
                <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 8px; text-align: center;">
                    Compete with your team! Share your code to create a private leaderboard.
                </p>
            </div>

            <!-- Industry Selector -->
            <div class="form-group" style="margin: 20px 0;">
                <label for="player-industry" style="display: block; margin-bottom: 10px; font-weight: 700; color: var(--primary); font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1.5px;">üè¢ Your Industry</label>
                <select id="player-industry" name="industry" aria-label="Select your industry" style="width: 100%; padding: 16px 20px; background: rgba(108, 92, 231, 0.1); border: 2px solid rgba(0, 255, 209, 0.2); border-radius: 14px; color: var(--text-light); font-size: 1rem; font-family: var(--font-body); font-weight: 500;">
                    <option value="other">Select your industry...</option>
                    <option value="banking">Banking & Financial Services</option>
                    <option value="healthcare">Healthcare & Life Sciences</option>
                    <option value="retail">Retail & Consumer Goods</option>
                    <option value="other">Other</option>
                </select>
            </div>

            <!-- Difficulty Selector -->
            <div class="difficulty-section">
                <h3>‚ö° Select Difficulty</h3>
                <div class="difficulty-options" id="difficulty-options">
                    <div class="difficulty-option" data-difficulty="easy">
                        <span class="difficulty-icon">üê¢</span>
                        <div class="difficulty-name">Easy</div>
                        <div class="difficulty-desc">Relaxed pace - Perfect for reading data challenges</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">0.5√ó Score</span>
                    </div>
                    <div class="difficulty-option selected" data-difficulty="normal">
                        <span class="difficulty-icon">üèÉ</span>
                        <div class="difficulty-name">Normal</div>
                        <div class="difficulty-desc">Balanced challenge for most players</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">1√ó Score</span>
                    </div>
                    <div class="difficulty-option" data-difficulty="hard">
                        <span class="difficulty-icon">üî•</span>
                        <div class="difficulty-name">Hard</div>
                        <div class="difficulty-desc">Fast & intense - For experienced players</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot"></span>
                        </div>
                        <span class="difficulty-multiplier">1.5√ó Score</span>
                    </div>
                    <div class="difficulty-option" data-difficulty="extreme">
                        <span class="difficulty-icon">üíÄ</span>
                        <div class="difficulty-name">Extreme</div>
                        <div class="difficulty-desc">Ultimate challenge - Only the brave survive!</div>
                        <div class="speed-indicator">
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                            <span class="speed-dot active"></span>
                        </div>
                        <span class="difficulty-multiplier">2√ó Score</span>
                    </div>
                </div>
            </div>

            <!-- Game Mode Selector -->
            <div class="mode-section" style="margin: 25px 0;">
                <h3 style="margin-bottom: 15px;">üéØ Game Mode</h3>
                <div class="mode-toggle" id="mode-toggle" style="display: flex; gap: 12px;">
                    <button class="mode-btn selected" data-mode="arcade" id="arcade-mode-btn" style="flex: 1; padding: 16px; background: rgba(108, 92, 231, 0.2); border: 2px solid var(--primary); border-radius: 12px; color: white; font-family: var(--font-body); font-size: 0.95rem; cursor: pointer; transition: all 0.3s;">
                        <span style="font-size: 1.5rem; display: block; margin-bottom: 5px;">üéÆ</span>
                        <strong>Arcade Mode</strong>
                        <span style="display: block; font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;">Classic gameplay with visual previews</span>
                    </button>
                    <button class="mode-btn" data-mode="learning" id="learning-mode-btn" style="flex: 1; padding: 16px; background: rgba(100, 200, 255, 0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-family: var(--font-body); font-size: 0.95rem; cursor: pointer; transition: all 0.3s;">
                        <span style="font-size: 1.5rem; display: block; margin-bottom: 5px;">üìö</span>
                        <strong>Learning Mode</strong>
                        <span style="display: block; font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;">Slower pace with Vault education</span>
                    </button>
                </div>
                <p id="mode-description" style="font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; text-align: center;">
                    üéÆ <strong>Arcade:</strong> Fast-paced action with hazard previews at the top of the screen
                </p>
            </div>
            
            <div class="game-instructions">
                <h3>üéØ How to Play</h3>
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    Each hazard represents a real data disaster that could impact your business. As you approach them, you'll see what they mean for your company. Jump over them to avoid the consequences!
                </p>
                <h3 style="margin-top: 20px;">‚å®Ô∏è Controls</h3>
                <ul>
                    <li><strong>SPACE / TAP</strong> - Jump over hazards</li>
                    <li><strong>‚Üë / ‚Üì ARROWS</strong> - Fine movement</li>
                    <li><strong>P</strong> - Pause game</li>
                    <li><strong>M</strong> - Toggle sound</li>
                </ul>
            </div>
            
            <button id="start-game-btn" class="btn btn-primary btn-full">
                ‚ö° Start Run
            </button>
        </div>
    </div>

    <!-- End Screen Modal -->
    <div id="end-modal" class="modal-overlay hidden" role="dialog" aria-labelledby="end-title" aria-modal="true">
        <div class="modal end-screen">
            <div class="logo-container">
                <div class="logo-icon" aria-hidden="true">üéÆ</div>
                <h1 id="end-title" class="game-title">Run Complete!</h1>
            </div>
            
            <p class="welcome-text" id="end-message">Great effort, Player!</p>
            
            <div class="score-display">
                <p class="score-label">Your Score</p>
                <p class="score-value" id="final-score">0</p>
            </div>
            
            <div class="badge-earned hidden" id="badge-section">
                <h4 id="badge-title">üèÖ Badge Unlocked!</h4>
                <p id="badge-description">Achievement unlocked</p>
            </div>

            <!-- Threats Learning Report -->
            <div class="threats-avoided-section" id="threats-avoided-section" style="background: rgba(0, 255, 136, 0.08); border: 2px solid rgba(0, 255, 136, 0.3); border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #00FF88; margin-bottom: 8px; font-size: 1.1rem;">üìö Your Security Learning Report</h4>
                <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div id="threats-count" style="font-size: 2.2rem; font-weight: bold; color: #00FF88;">0</div>
                        <p style="color: var(--text-muted); font-size: 0.8rem; margin: 0;">Threats Avoided</p>
                    </div>
                    <div style="width: 1px; height: 40px; background: rgba(255,255,255,0.2);"></div>
                    <div style="text-align: center;">
                        <div id="unique-threats-count" style="font-size: 2.2rem; font-weight: bold; color: #64C8FF;">0</div>
                        <p style="color: var(--text-muted); font-size: 0.8rem; margin: 0;">Hazards Learned</p>
                    </div>
                </div>
                <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 15px;">Here's what you learned about data protection today:</p>
                <div id="threats-list" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 15px;">
                    <!-- Detailed threat learning cards will be inserted here -->
                </div>
                <p id="vault-protection-message" style="color: #00FF88; font-size: 0.95rem; font-style: italic;">
                    With AutoRABIT Vault, recovery from any of these would take less than 15 minutes.
                </p>
            </div>

            <!-- Leaderboard Section -->
            <div class="leaderboard-section" id="leaderboard-section">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1.1rem;">üèÜ Leaderboard</h4>
                <div class="leaderboard-tabs">
                    <button class="leaderboard-tab active" data-tab="local" id="tab-local">Your Device</button>
                    <button class="leaderboard-tab" data-tab="global" id="tab-global">Global</button>
                </div>
                <div class="leaderboard-content" id="leaderboard-content">
                    <div class="leaderboard-loading">Loading...</div>
                </div>
            </div>
            
            <div class="vault-tip">
                <strong>üí° Vault Tip:</strong> In real life, data disasters strike without warning. AutoRABIT Vault provides enterprise-grade backup & recovery for your Salesforce org‚Äîso you never lose critical data.
            </div>
            
            <!-- Share Info Form -->
            <div class="share-info-section" id="share-info-section" style="background: rgba(0, 212, 255, 0.1); border: 2px solid rgba(0, 212, 255, 0.3); border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h4 style="color: var(--primary); margin-bottom: 15px; font-size: 1rem;">üìß Enter your info to share results</h4>
                <div class="form-group" style="margin-bottom: 12px;">
                    <input type="text" id="player-name" name="name" placeholder="Your name" style="width: 100%; padding: 14px 18px; background: rgba(108, 92, 231, 0.1); border: 2px solid rgba(0, 255, 209, 0.2); border-radius: 12px; color: var(--text-light); font-size: 1rem; font-family: var(--font-body);">
                    <p class="form-error" id="name-error" style="color: var(--danger); font-size: 0.8rem; margin-top: 6px; display: none;">Please enter your name</p>
                </div>
                <div class="form-group" style="margin-bottom: 15px;">
                    <input type="email" id="player-email" name="email" placeholder="your@email.com" style="width: 100%; padding: 14px 18px; background: rgba(108, 92, 231, 0.1); border: 2px solid rgba(0, 255, 209, 0.2); border-radius: 12px; color: var(--text-light); font-size: 1rem; font-family: var(--font-body);">
                    <p class="form-error" id="email-error" style="color: var(--danger); font-size: 0.8rem; margin-top: 6px; display: none;">Please enter a valid email address</p>
                </div>
                <button type="button" id="unlock-share-btn" class="btn btn-primary btn-full" style="padding: 14px 20px;">
                    üîì Unlock Sharing
                </button>
                <p id="share-unlocked-msg" style="display: none; color: var(--success); text-align: center; margin-top: 10px; font-weight: 600;">‚úì Sharing unlocked!</p>
            </div>
            
            <div class="share-section" id="share-section">
                <h4>üì¢ Share Your Score</h4>
                <div class="share-buttons">
                    <button class="btn btn-social btn-x" id="share-x" aria-label="Share on X" disabled style="opacity: 0.5; cursor: not-allowed;">
                        ùïè Post
                    </button>
                    <button class="btn btn-social btn-linkedin" id="share-linkedin" aria-label="Share on LinkedIn" disabled style="opacity: 0.5; cursor: not-allowed;">
                        in Share
                    </button>
                    <button class="btn btn-social btn-email" id="email-results" aria-label="Email results to yourself" disabled style="opacity: 0.5; cursor: not-allowed;">
                        ‚úâÔ∏è Email Me
                    </button>
                    <button class="btn btn-social btn-friend" id="email-friend" aria-label="Email to a friend" disabled style="opacity: 0.5; cursor: not-allowed;">
                        üë• Send to Friend
                    </button>
                </div>
            </div>
            
            <!-- Download Certificate Section -->
            <div class="certificate-section" id="certificate-section" style="background: linear-gradient(135deg, rgba(100, 200, 255, 0.1), rgba(108, 92, 231, 0.1)); border: 2px solid rgba(100, 200, 255, 0.3); border-radius: 12px; padding: 20px; margin: 20px 0; text-align: center;">
                <h4 style="color: #64C8FF; margin-bottom: 10px; font-size: 1rem;">üéì Download Your Achievement</h4>
                <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 15px;">
                    Get a shareable certificate for LinkedIn showing your data protection expertise!
                </p>
                <button id="download-certificate" class="btn btn-social" style="background: linear-gradient(135deg, #0077B5, #00A0DC); border: none; padding: 12px 24px; font-size: 0.9rem;">
                    üìú Download Certificate
                </button>
                <button id="copy-challenge-link" class="btn btn-social" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 12px 24px; font-size: 0.9rem; margin-left: 10px;">
                    üîó Copy Challenge Link
                </button>
            </div>

            <div class="action-buttons">
                <a href="#" id="cta-button" class="btn btn-cta btn-full" target="_blank" rel="noopener">
                    üõ°Ô∏è Start Free Vault Trial
                </a>
                <button id="play-again-btn" class="btn btn-secondary btn-full">
                    üîÑ Play Again
                </button>
            </div>
        </div>
    </div>

    <!-- Email to Friend Modal -->
    <div id="friend-modal" class="friend-modal hidden" role="dialog" aria-labelledby="friend-modal-title" aria-modal="true">
        <div class="friend-modal-content">
            <h3 id="friend-modal-title">üìß Challenge a Friend!</h3>
            <p style="color: var(--text-muted); margin-bottom: 20px; font-size: 0.9rem;">Send your score and challenge them to beat it!</p>
            <input type="email" id="friend-email" placeholder="friend@company.com" aria-label="Friend's email address">
            <div class="friend-modal-buttons">
                <button class="btn btn-secondary" id="friend-cancel">Cancel</button>
                <button class="btn btn-primary" id="friend-send">Send Challenge</button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="hidden">
        <canvas id="gameCanvas" aria-label="Recovery Runner Game"></canvas>
        
        <!-- HUD -->
        <div class="hud" role="status" aria-live="polite">
            <div class="hud-item">
                <div class="hud-lives" id="hud-lives">
                    <span class="heart active">‚ù§Ô∏è</span>
                    <span class="heart active">‚ù§Ô∏è</span>
                    <span class="heart active">‚ù§Ô∏è</span>
                </div>
                <div class="hud-score">
                    Score: <span id="hud-score">0</span>
                </div>
                <div class="hud-difficulty" id="hud-difficulty">
                    <span id="hud-difficulty-icon">üèÉ</span> <span id="hud-difficulty-name">Normal</span>
                </div>
            </div>
            <div class="hud-item hud-controls">
                <button class="hud-btn" id="pause-btn" aria-label="Pause game">‚è∏Ô∏è Pause</button>
                <button class="hud-btn" id="mute-btn" aria-label="Toggle sound">üîä</button>
            </div>
        </div>
        
        <!-- Power-up Indicator -->
        <div class="power-up-indicator hidden" id="power-up-indicator">
            üõ°Ô∏è VAULT SHIELD ACTIVE
        </div>
        
        <!-- Wave Warning Banner -->
        <div class="wave-banner hidden" id="wave-banner">
            ‚ö†Ô∏è INCOMING WAVE ‚ö†Ô∏è
        </div>
        
        <!-- Combo Display -->
        <div class="combo-display hidden" id="combo-display">
            <span id="combo-count">1</span>x COMBO
        </div>
        
        <!-- Pause Overlay -->
        <div class="pause-overlay hidden" id="pause-overlay">
            <div class="pause-content">
                <h2>‚è∏Ô∏è PAUSED</h2>
                <button class="btn btn-primary" id="resume-btn">‚ñ∂Ô∏è Resume</button>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobile-controls">
            <button class="mobile-btn" id="mobile-jump" aria-label="Jump">‚¨ÜÔ∏è</button>
        </div>
    </div>

    <script>
    /* ==========================================
       RECOVERY RUNNER - GAME ENGINE
       AutoRABIT Vault Marketing Game
       ========================================== */

    // ==========================================
    // CONFIGURATION & CONSTANTS
    // ==========================================
    const CONFIG = {
        CANVAS_WIDTH: 900,
        CANVAS_HEIGHT: 500,
        GROUND_HEIGHT: 80,
        GRAVITY: 0.8,
        JUMP_FORCE: -15,
        INITIAL_SPEED: 6,
        MAX_SPEED: 15,
        SPEED_INCREMENT: 0.001,
        ORB_SPAWN_RATE: 0.02,
        HAZARD_SPAWN_RATE: 0.015,
        POWERUP_SPAWN_RATE: 0.003,
        SHIELD_DURATION: 5000,
        PLAYER_WIDTH: 50,
        PLAYER_HEIGHT: 60
    };

    // Difficulty presets - affects speed and spawn rates
    // Hazard spawn rates significantly reduced to allow educational reading
    const DIFFICULTY_PRESETS = {
        easy: {
            name: 'Easy',
            description: 'Relaxed pace - Perfect for reading data challenges',
            initialSpeed: 3,
            maxSpeed: 6,
            speedIncrement: 0.0003,
            hazardSpawnRate: 0.003,      // Very low - ~1 hazard every 5-6 seconds
            minHazardGap: 400,            // Minimum 400px between hazards
            orbSpawnRate: 0.02,
            powerupSpawnRate: 0.006,
            shieldDuration: 8000,
            scoreMultiplier: 0.5,
            icon: 'üê¢'
        },
        normal: {
            name: 'Normal',
            description: 'Balanced challenge for most players',
            initialSpeed: 5,
            maxSpeed: 10,
            speedIncrement: 0.0008,
            hazardSpawnRate: 0.006,       // Reduced - ~1 hazard every 3 seconds
            minHazardGap: 300,            // Minimum 300px between hazards
            orbSpawnRate: 0.018,
            powerupSpawnRate: 0.004,
            shieldDuration: 6000,
            scoreMultiplier: 1.0,
            icon: 'üèÉ'
        },
        hard: {
            name: 'Hard',
            description: 'Fast & intense - For experienced players',
            initialSpeed: 7,
            maxSpeed: 14,
            speedIncrement: 0.001,
            hazardSpawnRate: 0.01,        // Reduced - ~1 hazard every 1.5-2 seconds
            minHazardGap: 200,            // Minimum 200px between hazards
            orbSpawnRate: 0.015,
            powerupSpawnRate: 0.003,
            shieldDuration: 5000,
            scoreMultiplier: 1.5,
            icon: 'üî•'
        },
        extreme: {
            name: 'Extreme',
            description: 'Ultimate challenge - Only the brave survive!',
            initialSpeed: 9,
            maxSpeed: 18,
            speedIncrement: 0.0015,
            hazardSpawnRate: 0.015,       // Reduced - ~1 hazard every 1-1.5 seconds
            minHazardGap: 150,            // Minimum 150px between hazards
            orbSpawnRate: 0.012,
            powerupSpawnRate: 0.002,
            shieldDuration: 4000,
            scoreMultiplier: 2.0,
            icon: 'üíÄ'
        }
    };

            // Hazard descriptions with business impact
    const HAZARD_DESCRIPTIONS = {
        'Loan Overwrite': 'Critical loan data accidentally overwritten - can result in regulatory fines and customer trust loss',
        'Compliance Breach': 'Violation of banking regulations - leads to massive fines and potential license revocation',
        'Audit Fail': 'Failed compliance audit - triggers regulatory investigations and business disruption',
        'Rate Sync Error': 'Interest rate synchronization failure - causes incorrect loan calculations and financial losses',
        'Document Leak': 'Sensitive banking documents exposed - results in data breach penalties and reputation damage',
        'FlexCard Corruption': 'Customer-facing card component fails - impacts patient experience and operational efficiency',
        'Process Fail': 'Critical healthcare process breaks down - delays patient care and violates service level agreements',
        'HIPAA Breach': 'Protected health information exposed - triggers $1M+ fines and legal liability',
        'Record Sync Error': 'Patient record synchronization fails - causes duplicate records and treatment errors',
        'PHI Exposure': 'Protected health information leaked - results in HIPAA violations and patient trust loss',
        'Cart Corruption': 'Shopping cart data corrupted - causes lost sales and customer frustration',
        'Order Sync Fail': 'Order synchronization failure - results in inventory mismatches and shipping errors',
        'Inventory Wipe': 'Product inventory data deleted - causes stockouts and revenue loss',
        'Price Override': 'Product pricing accidentally changed - leads to incorrect charges and customer complaints',
        'Customer Loss': 'Customer data permanently lost - results in relationship damage and revenue decline',
        'Metadata Loss': 'Salesforce configuration and customizations deleted - requires weeks to rebuild',
        'API Limit Hit': 'API usage exceeds limits - causes integration failures and business process breakdown',
        'Sandbox Wipe': 'Development sandbox data lost - delays releases and increases development costs',
        'Config Corrupt': 'Salesforce configuration corrupted - breaks business processes and user workflows',
        'Deploy Fail': 'Deployment failure with data loss - requires rollback and causes production downtime'
    };

    // Vault solutions and hazard metadata for educational content
    const VAULT_SOLUTIONS = {
        'Loan Overwrite': {
            icon: 'üíæ',
            category: 'data_loss',
            impact: 'üí∞ $50K+ regulatory fines',
            severity: 'critical',
            vaultSolution: 'Point-in-time recovery restores exact loan data in under 5 minutes',
            recoveryTime: '< 5 min'
        },
        'Compliance Breach': {
            icon: '‚öñÔ∏è',
            category: 'compliance',
            impact: 'üìã License revocation risk',
            severity: 'critical',
            vaultSolution: 'Automated compliance snapshots ensure audit-ready data restoration',
            recoveryTime: '< 10 min'
        },
        'Audit Fail': {
            icon: 'üìä',
            category: 'compliance',
            impact: 'üîç Regulatory investigation',
            severity: 'high',
            vaultSolution: 'Complete audit trail with granular recovery to any point in time',
            recoveryTime: '< 15 min'
        },
        'Rate Sync Error': {
            icon: 'üîÑ',
            category: 'sync',
            impact: 'üí∏ Financial calculation errors',
            severity: 'high',
            vaultSolution: 'Selective field-level recovery corrects sync issues without full restore',
            recoveryTime: '< 3 min'
        },
        'Document Leak': {
            icon: 'üîì',
            category: 'security',
            impact: 'üõ°Ô∏è Data breach penalties',
            severity: 'critical',
            vaultSolution: 'Instant rollback to pre-breach state with complete data integrity',
            recoveryTime: '< 5 min'
        },
        'FlexCard Corruption': {
            icon: 'üé¥',
            category: 'data_loss',
            impact: 'üòû Patient experience degraded',
            severity: 'medium',
            vaultSolution: 'Component-level recovery restores UI configurations instantly',
            recoveryTime: '< 2 min'
        },
        'Process Fail': {
            icon: '‚öôÔ∏è',
            category: 'sync',
            impact: '‚è±Ô∏è Patient care delays',
            severity: 'high',
            vaultSolution: 'Process definition recovery with dependency tracking',
            recoveryTime: '< 5 min'
        },
        'HIPAA Breach': {
            icon: 'üè•',
            category: 'compliance',
            impact: 'üí∞ $1M+ HIPAA fines',
            severity: 'critical',
            vaultSolution: 'Encrypted backups with instant recovery maintain HIPAA compliance',
            recoveryTime: '< 10 min'
        },
        'Record Sync Error': {
            icon: 'üîÑ',
            category: 'sync',
            impact: '‚ö†Ô∏è Treatment errors possible',
            severity: 'high',
            vaultSolution: 'Record-level comparison and selective sync correction',
            recoveryTime: '< 3 min'
        },
        'PHI Exposure': {
            icon: 'üîê',
            category: 'security',
            impact: 'üìâ Patient trust loss',
            severity: 'critical',
            vaultSolution: 'Immediate data state rollback with exposure timeline tracking',
            recoveryTime: '< 5 min'
        },
        'Cart Corruption': {
            icon: 'üõí',
            category: 'data_loss',
            impact: 'üí∏ Lost sales revenue',
            severity: 'high',
            vaultSolution: 'Transaction-aware recovery preserves customer cart state',
            recoveryTime: '< 2 min'
        },
        'Order Sync Fail': {
            icon: 'üì¶',
            category: 'sync',
            impact: 'üì¶ Shipping errors',
            severity: 'high',
            vaultSolution: 'Order state reconciliation with inventory sync validation',
            recoveryTime: '< 5 min'
        },
        'Inventory Wipe': {
            icon: 'üìã',
            category: 'data_loss',
            impact: 'üö´ Stockout crisis',
            severity: 'critical',
            vaultSolution: 'Bulk inventory restoration with real-time stock level recovery',
            recoveryTime: '< 10 min'
        },
        'Price Override': {
            icon: 'üí≤',
            category: 'data_loss',
            impact: 'üò§ Customer complaints',
            severity: 'medium',
            vaultSolution: 'Price history tracking with selective field restoration',
            recoveryTime: '< 2 min'
        },
        'Customer Loss': {
            icon: 'üë•',
            category: 'data_loss',
            impact: 'üìâ Revenue decline',
            severity: 'critical',
            vaultSolution: 'Complete customer record recovery with relationship preservation',
            recoveryTime: '< 5 min'
        },
        'Metadata Loss': {
            icon: 'üóÇÔ∏è',
            category: 'data_loss',
            impact: 'üîß Weeks to rebuild',
            severity: 'critical',
            vaultSolution: 'Full metadata backup with dependency-aware restoration',
            recoveryTime: '< 15 min'
        },
        'API Limit Hit': {
            icon: 'üîå',
            category: 'sync',
            impact: '‚õî Integration failures',
            severity: 'high',
            vaultSolution: 'Cached data recovery bypasses API limits during restoration',
            recoveryTime: '< 5 min'
        },
        'Sandbox Wipe': {
            icon: 'üèñÔ∏è',
            category: 'data_loss',
            impact: 'üìÖ Release delays',
            severity: 'high',
            vaultSolution: 'Sandbox-specific backups with rapid environment recreation',
            recoveryTime: '< 20 min'
        },
        'Config Corrupt': {
            icon: '‚öôÔ∏è',
            category: 'data_loss',
            impact: 'üî• Process breakdown',
            severity: 'critical',
            vaultSolution: 'Configuration versioning with instant rollback capability',
            recoveryTime: '< 5 min'
        },
        'Deploy Fail': {
            icon: 'üöÄ',
            category: 'sync',
            impact: '‚è∞ Production downtime',
            severity: 'critical',
            vaultSolution: 'Pre-deployment snapshots enable instant rollback on failure',
            recoveryTime: '< 3 min'
        }
    };

    // Category colors for distinct hazard visuals
    const HAZARD_CATEGORIES = {
        data_loss: { color: '#FF6B6B', shape: 'broken_disk' },
        compliance: { color: '#FFD93D', shape: 'scale' },
        security: { color: '#FF4757', shape: 'broken_lock' },
        sync: { color: '#FFA502', shape: 'broken_sync' }
    };

    // Industry-specific themes
    const THEMES = {
        banking: {
            name: 'nCino Banking',
            greeting: 'Secure your Banking Data!',
            hazards: ['Loan Overwrite', 'Compliance Breach', 'Audit Fail', 'Rate Sync Error', 'Document Leak'],
            collectibles: ['Secure Loan', 'Compliance Check', 'Audit Pass'],
            colors: {
                primary: '#00D4FF',
                secondary: '#FF6B9D',
                accent: '#FFD93D',
                hazard: '#FF4757',
                bg: '#1A1A2E'
            },
            badge: { name: 'Data Guardian', threshold: 300, icon: 'üè¶' },
            waves: ['Regulatory Fine Wave', 'Loan Default Storm', 'Compliance Audit Surge']
        },
        healthcare: {
            name: 'OmniStudio Health',
            greeting: 'Protect Patient Data!',
            hazards: ['FlexCard Corruption', 'Process Fail', 'HIPAA Breach', 'Record Sync Error', 'PHI Exposure'],
            collectibles: ['OmniScript', 'FlexCard', 'DataRaptor'],
            colors: {
                primary: '#00D4FF',
                secondary: '#FF6B9D',
                accent: '#FFD93D',
                hazard: '#FF4757',
                bg: '#1A1A2E'
            },
            badge: { name: 'Data Guardian', threshold: 300, icon: '‚öïÔ∏è' },
            waves: ['UI Glitch Swarm', 'Integration Crash', 'Data Flow Disruption']
        },
        retail: {
            name: 'OmniStudio Commerce',
            greeting: 'Guard Your Commerce Data!',
            hazards: ['Cart Corruption', 'Order Sync Fail', 'Inventory Wipe', 'Price Override', 'Customer Loss'],
            collectibles: ['Order Data', 'Customer Record', 'Product Sync'],
            colors: {
                primary: '#00D4FF',
                secondary: '#FF6B9D',
                accent: '#FFD93D',
                hazard: '#FF4757',
                bg: '#1A1A2E'
            },
            badge: { name: 'Data Guardian', threshold: 300, icon: 'üõí' },
            waves: ['Flash Sale Crash', 'Inventory Chaos', 'Cart Abandonment Storm']
        },
        other: {
            name: 'Salesforce Org',
            greeting: 'Defend Your Salesforce Org!',
            hazards: ['Metadata Loss', 'API Limit Hit', 'Sandbox Wipe', 'Config Corrupt', 'Deploy Fail'],
            collectibles: ['Sandbox Orb', 'Metadata Pack', 'Config Backup'],
            colors: {
                primary: '#00D4FF',
                secondary: '#FF6B9D',
                accent: '#FFD93D',
                hazard: '#FF4757',
                bg: '#1A1A2E'
            },
            badge: { name: 'Data Guardian', threshold: 300, icon: '‚òÅÔ∏è' },
            waves: ['Ransomware Attack', 'Mass Delete Storm', 'Integration Nightmare']
        }
    };

    // ==========================================
    // GAME STATE
    // ==========================================
    let gameState = {
        player: null,
        isRunning: false,
        isPaused: false,
        score: 0,
        highScore: 0,
        speed: CONFIG.INITIAL_SPEED,
        hazards: [],
        orbs: [],
        powerups: [],
        particles: [],
        bgElements: [],
        shieldActive: false,
        shieldEndTime: 0,
        waveTimer: 0,
        currentWave: null,
        soundEnabled: true,
        theme: THEMES.other,
        userData: { name: '', email: '', industry: 'other' },
        shareUnlocked: false,
        // Lives system
        lives: 3,
        maxLives: 3,
        invincible: false,
        invincibleEndTime: 0,
        screenShake: 0,
        // Combo system
        combo: 0,
        maxCombo: 0,
        comboTimer: 0,
        lastCollectTime: 0,
        multiplier: 1,
        distance: 0,
        // Difficulty settings
        difficulty: 'normal',
        difficultySettings: DIFFICULTY_PRESETS.normal,
        // Learning mode
        learningMode: false,
        learningPaused: false,
        currentLearningHazard: null,
        learningResumeTimer: null,
        // Threat tracking
        threatsAvoided: 0,
        threatsAvoidedList: [],
        // Protected flash effects
        protectedFlash: null,
        // Game loop guard to prevent multiple loops
        loopRunning: false,
        // Streak & Viral features
        streak: 0,
        lastPlayDate: null,
        teamCode: null,
        referrer: null
    };

    // ==========================================
    // DOM ELEMENTS
    // ==========================================
    const elements = {
        startModal: document.getElementById('start-modal'),
        endModal: document.getElementById('end-modal'),
        gameContainer: document.getElementById('game-container'),
        canvas: document.getElementById('gameCanvas'),
        playerName: document.getElementById('player-name'),
        playerEmail: document.getElementById('player-email'),
        playerIndustry: document.getElementById('player-industry'),
        nameError: document.getElementById('name-error'),
        emailError: document.getElementById('email-error'),
        industryIntro: document.getElementById('industry-intro'),
        highScoreValue: document.getElementById('high-score-value'),
        startGameBtn: document.getElementById('start-game-btn'),
        endMessage: document.getElementById('end-message'),
        finalScore: document.getElementById('final-score'),
        badgeSection: document.getElementById('badge-section'),
        badgeTitle: document.getElementById('badge-title'),
        badgeDescription: document.getElementById('badge-description'),
        ctaButton: document.getElementById('cta-button'),
        playAgainBtn: document.getElementById('play-again-btn'),
        shareX: document.getElementById('share-x'),
        shareLinkedIn: document.getElementById('share-linkedin'),
        emailResults: document.getElementById('email-results'),
        emailFriend: document.getElementById('email-friend'),
        friendModal: document.getElementById('friend-modal'),
        friendEmail: document.getElementById('friend-email'),
        friendCancel: document.getElementById('friend-cancel'),
        friendSend: document.getElementById('friend-send'),
        hudScore: document.getElementById('hud-score'),
        hudLives: document.getElementById('hud-lives'),
        pauseBtn: document.getElementById('pause-btn'),
        muteBtn: document.getElementById('mute-btn'),
        pauseOverlay: document.getElementById('pause-overlay'),
        resumeBtn: document.getElementById('resume-btn'),
        powerUpIndicator: document.getElementById('power-up-indicator'),
        mobileJump: document.getElementById('mobile-jump'),
        difficultyOptions: document.getElementById('difficulty-options'),
        hudDifficultyIcon: document.getElementById('hud-difficulty-icon'),
        hudDifficultyName: document.getElementById('hud-difficulty-name'),
        // Mode toggle elements
        modeToggle: document.getElementById('mode-toggle'),
        arcadeModeBtn: document.getElementById('arcade-mode-btn'),
        learningModeBtn: document.getElementById('learning-mode-btn'),
        modeDescription: document.getElementById('mode-description'),
        // Share unlock elements
        shareInfoSection: document.getElementById('share-info-section'),
        unlockShareBtn: document.getElementById('unlock-share-btn'),
        shareUnlockedMsg: document.getElementById('share-unlocked-msg'),
        shareSection: document.getElementById('share-section'),
        // Viral feature elements
        streakSection: document.getElementById('streak-section'),
        streakCount: document.getElementById('streak-count'),
        streakBonus: document.getElementById('streak-bonus'),
        teamCodeInput: document.getElementById('team-code-input'),
        generateTeamCodeBtn: document.getElementById('generate-team-code'),
        downloadCertificate: document.getElementById('download-certificate'),
        copyChallengeLink: document.getElementById('copy-challenge-link')
    };

    const ctx = elements.canvas.getContext('2d');

    // ==========================================
    // AUDIO SYSTEM (Web Audio API)
    // ==========================================
    let audioCtx = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playSound(type) {
        if (!gameState.soundEnabled || !audioCtx) return;
        
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        switch(type) {
            case 'jump':
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.15);
                break;
            case 'collect':
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.1);
                break;
            case 'powerup':
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.4);
                break;
            case 'hit':
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
                break;
            case 'wave':
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.4);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.5);
                break;
        }
    }

    // ==========================================
    // ANALYTICS STUBS
    // ==========================================
    function trackEvent(eventName, params = {}) {
        // Google Analytics 4 event tracking stub
        // Uncomment and configure when ready to deploy:
        /*
        if (typeof gtag !== 'undefined') {
            gtag('event', eventName, params);
        }
        */
        console.log('[Analytics]', eventName, params);
    }

    // ==========================================
    // LOCAL STORAGE UTILITIES
    // ==========================================
    function saveUserData(data) {
        try {
            localStorage.setItem('recoveryRunner_user', JSON.stringify(data));
        } catch (e) {
            console.warn('Could not save user data:', e);
        }
    }

    function loadUserData() {
        try {
            const data = localStorage.getItem('recoveryRunner_user');
            return data ? JSON.parse(data) : null;
        } catch (e) {
            console.warn('Could not load user data:', e);
            return null;
        }
    }

    function saveHighScore(score) {
        try {
            const currentHigh = parseInt(localStorage.getItem('recoveryRunner_highScore') || '0');
            if (score > currentHigh) {
                localStorage.setItem('recoveryRunner_highScore', score.toString());
                // Global leaderboard stub
                console.log('[Leaderboard] New high score:', score, 'for user:', gameState.userData.email);
                return true;
            }
        } catch (e) {
            console.warn('Could not save high score:', e);
        }
        return false;
    }

    function loadHighScore() {
        try {
            return parseInt(localStorage.getItem('recoveryRunner_highScore') || '0');
        } catch (e) {
            return 0;
        }
    }

    // ==========================================
    // LOCAL LEADERBOARD
    // ==========================================
    function saveToLocalLeaderboard(score) {
        try {
            const entry = {
                name: gameState.userData.name || 'Anonymous',
                score: score,
                industry: gameState.userData.industry || 'other',
                date: new Date().toISOString()
            };
            let leaderboard = JSON.parse(localStorage.getItem('recoveryRunner_leaderboard') || '[]');
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10);
            localStorage.setItem('recoveryRunner_leaderboard', JSON.stringify(leaderboard));
        } catch (e) {
            console.warn('Could not save to local leaderboard:', e);
        }
    }

    function getLocalLeaderboard() {
        try {
            return JSON.parse(localStorage.getItem('recoveryRunner_leaderboard') || '[]');
        } catch (e) {
            console.warn('Could not load local leaderboard:', e);
            return [];
        }
    }

    // Update the most recent leaderboard entry with user's name (called after unlock sharing)
    function updateRecentLeaderboardEntry(name) {
        try {
            let leaderboard = JSON.parse(localStorage.getItem('recoveryRunner_leaderboard') || '[]');
            
            // Find the most recent entry with current score and "Anonymous" name
            for (let i = 0; i < leaderboard.length; i++) {
                if (leaderboard[i].score === gameState.score && 
                    (leaderboard[i].name === 'Anonymous' || !leaderboard[i].name)) {
                    leaderboard[i].name = name;
                    localStorage.setItem('recoveryRunner_leaderboard', JSON.stringify(leaderboard));
                    console.log('[Leaderboard] Updated entry with name:', name);
                    break;
                }
            }
        } catch (e) {
            console.warn('Could not update leaderboard entry:', e);
        }
    }

    // ==========================================
    // GLOBAL LEADERBOARD (Firebase)
    // ==========================================
    // Firebase configuration - Replace with your project's config
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY",
        authDomain: "YOUR_PROJECT.firebaseapp.com",
        databaseURL: "https://YOUR_PROJECT-default-rtdb.firebaseio.com",
        projectId: "YOUR_PROJECT",
        storageBucket: "YOUR_PROJECT.appspot.com",
        messagingSenderId: "YOUR_SENDER_ID",
        appId: "YOUR_APP_ID"
    };

    // Initialize Firebase (only if config is set)
    let firebaseApp = null;
    let database = null;
    
    function initFirebase() {
        if (firebaseApp) return true;
        if (firebaseConfig.apiKey === "YOUR_API_KEY") {
            console.log('[Firebase] Not configured - global leaderboard disabled');
            return false;
        }
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log('[Firebase] Initialized successfully');
            return true;
        } catch (e) {
            console.warn('[Firebase] Could not initialize:', e);
            return false;
        }
    }

    async function submitToGlobalLeaderboard(score) {
        if (!initFirebase()) return false;
        try {
            const entry = {
                name: gameState.userData.name || 'Anonymous',
                score: score,
                industry: gameState.userData.industry || 'other',
                difficulty: gameState.difficulty,
                date: Date.now()
            };
            await database.ref('leaderboard').push(entry);
            console.log('[Firebase] Score submitted to global leaderboard');
            return true;
        } catch (e) {
            console.warn('[Firebase] Could not submit score:', e);
            return false;
        }
    }

    async function fetchGlobalLeaderboard() {
        if (!initFirebase()) return [];
        try {
            const snapshot = await database.ref('leaderboard')
                .orderByChild('score')
                .limitToLast(10)
                .once('value');
            const entries = [];
            snapshot.forEach(child => entries.push(child.val()));
            return entries.sort((a, b) => b.score - a.score);
        } catch (e) {
            console.warn('[Firebase] Could not fetch leaderboard:', e);
            return [];
        }
    }

    // ==========================================
    // STREAK SYSTEM (Viral Feature)
    // ==========================================
    function loadStreak() {
        try {
            const streakData = JSON.parse(localStorage.getItem('recoveryRunner_streak') || '{}');
            const today = new Date().toDateString();
            const lastPlay = streakData.lastPlayDate;
            
            if (!lastPlay) {
                return { streak: 0, isNewDay: true };
            }
            
            const lastDate = new Date(lastPlay);
            const diffDays = Math.floor((new Date(today) - lastDate) / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return { streak: streakData.streak || 1, isNewDay: false };
            } else if (diffDays === 1) {
                return { streak: (streakData.streak || 0) + 1, isNewDay: true };
            } else {
                return { streak: 1, isNewDay: true };
            }
        } catch (e) {
            return { streak: 1, isNewDay: true };
        }
    }

    function saveStreak(streak) {
        try {
            localStorage.setItem('recoveryRunner_streak', JSON.stringify({
                streak: streak,
                lastPlayDate: new Date().toDateString()
            }));
        } catch (e) {
            console.warn('Could not save streak:', e);
        }
    }

    function getStreakBonus(streak) {
        // 5% bonus per day, max 50%
        return Math.min(streak * 5, 50);
    }

    // ==========================================
    // TEAM CODE SYSTEM (Viral Feature)
    // ==========================================
    function loadTeamCode() {
        try {
            return localStorage.getItem('recoveryRunner_teamCode') || null;
        } catch (e) {
            return null;
        }
    }

    function saveTeamCode(code) {
        try {
            localStorage.setItem('recoveryRunner_teamCode', code);
            gameState.teamCode = code;
        } catch (e) {
            console.warn('Could not save team code:', e);
        }
    }

    function generateTeamCode() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let code = '';
        for (let i = 0; i < 6; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
    }

    // ==========================================
    // REFERRAL TRACKING (Viral Feature)
    // ==========================================
    function detectReferral() {
        try {
            const params = new URLSearchParams(window.location.search);
            const ref = params.get('ref') || params.get('challenge');
            if (ref) {
                gameState.referrer = ref;
                trackEvent('referred_visit', { referrer: ref });
                console.log('[Referral] User came from:', ref);
            }
        } catch (e) {
            console.warn('Could not detect referral:', e);
        }
    }

    // ==========================================
    // SECURITY CERTIFICATE (Viral Feature)
    // ==========================================
    function generateCertificateData() {
        const tier = gameState.score >= 700 ? 'Expert' : gameState.score >= 300 ? 'Pro' : 'Intern';
        const tierEmoji = gameState.score >= 700 ? 'üèÜ' : gameState.score >= 300 ? '‚≠ê' : 'üìö';
        const date = new Date().toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        
        return {
            name: gameState.userData.name || 'Data Protection Champion',
            score: gameState.score,
            tier: tier,
            tierEmoji: tierEmoji,
            industry: gameState.theme.name,
            threatsDefeated: gameState.threatsAvoided,
            uniqueThreats: gameState.threatsAvoidedList.length,
            streak: gameState.streak,
            date: date,
            certificateId: `VLT-${Date.now().toString(36).toUpperCase()}`
        };
    }

    function generateShareableLink() {
        const cert = generateCertificateData();
        const params = new URLSearchParams({
            challenge: gameState.userData.name || 'Champion',
            score: gameState.score,
            tier: cert.tier
        });
        return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
    }

    // ==========================================
    // VALIDATION
    // ==========================================
    function validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }

    // ==========================================
    // GAME CLASSES
    // ==========================================
    class Player {
        constructor() {
            this.x = 100;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - CONFIG.PLAYER_HEIGHT;
            this.width = CONFIG.PLAYER_WIDTH;
            this.height = CONFIG.PLAYER_HEIGHT;
            this.velocityY = 0;
            this.isJumping = false;
            this.frame = 0;
            this.animTimer = 0;
        }

        jump() {
            if (!this.isJumping) {
                this.velocityY = CONFIG.JUMP_FORCE;
                this.isJumping = true;
                playSound('jump');
            }
        }

        update() {
            // Apply gravity
            this.velocityY += CONFIG.GRAVITY;
            this.y += this.velocityY;

            // Ground collision
            const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
            if (this.y >= groundY) {
                this.y = groundY;
                this.velocityY = 0;
                this.isJumping = false;
            }

            // Animation
            this.animTimer++;
            if (this.animTimer > 5) {
                this.frame = (this.frame + 1) % 4;
                this.animTimer = 0;
            }
        }

        draw(ctx) {
            const theme = gameState.theme;
            const runCycle = Math.sin(this.frame * Math.PI / 2);
            const bobOffset = Math.abs(runCycle) * 2;
            const armSwing = runCycle * 8;
            const coffeeWobble = this.isJumping ? Math.sin(Date.now() / 80) * 4 : runCycle * 2;
            
            // Invincibility flash effect
            if (gameState.invincible) {
                const flash = Math.sin(Date.now() / 50);
                if (flash > 0.3) {
                    ctx.globalAlpha = 0.5;
                }
            }
            
            // Draw shield effect if active
            if (gameState.shieldActive) {
                ctx.save();
                const shieldPulse = Math.sin(Date.now() / 100) * 5 + 45;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, shieldPulse, 0, Math.PI * 2);
                ctx.strokeStyle = theme.colors.primary;
                ctx.lineWidth = 3;
                ctx.shadowColor = theme.colors.primary;
                ctx.shadowBlur = 30;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width * 0.75, 0, Math.PI * 2);
                ctx.fillStyle = `${theme.colors.primary}22`;
                ctx.fill();
                ctx.restore();
            }

            ctx.save();
            
            // Character shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(this.x + this.width/2, this.y + this.height + 2, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // === LEGS (Dark pants) ===
            ctx.fillStyle = '#2C3E50';
            // Left leg
            const leftLegY = this.y + 38 - bobOffset;
            ctx.beginPath();
            ctx.roundRect(this.x + 15, leftLegY + runCycle * 5, 8, 22 - Math.max(0, runCycle * 3), 2);
            ctx.fill();
            // Right leg
            ctx.beginPath();
            ctx.roundRect(this.x + 27, leftLegY - runCycle * 5, 8, 22 + Math.min(0, runCycle * 3), 2);
            ctx.fill();
            
            // === SHOES ===
            ctx.fillStyle = '#1A1A2E';
            ctx.beginPath();
            ctx.roundRect(this.x + 13, this.y + this.height - 8 + runCycle * 5, 12, 6, 2);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(this.x + 25, this.y + this.height - 8 - runCycle * 5, 12, 6, 2);
            ctx.fill();
            
            // === TORSO (Blue shirt) ===
            const shirtGrad = ctx.createLinearGradient(this.x + 10, this.y + 18, this.x + 40, this.y + 45);
            shirtGrad.addColorStop(0, '#3498DB');
            shirtGrad.addColorStop(1, '#2980B9');
            ctx.fillStyle = shirtGrad;
            ctx.beginPath();
            ctx.roundRect(this.x + 10, this.y + 18 - bobOffset, 30, 24, 3);
            ctx.fill();
            
            // === TIE ===
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.moveTo(this.x + 25, this.y + 18 - bobOffset);
            ctx.lineTo(this.x + 28, this.y + 22 - bobOffset);
            ctx.lineTo(this.x + 25, this.y + 38 - bobOffset);
            ctx.lineTo(this.x + 22, this.y + 22 - bobOffset);
            ctx.closePath();
            ctx.fill();
            
            // === ARMS ===
            ctx.fillStyle = '#3498DB';
            // Back arm (swinging)
            ctx.beginPath();
            ctx.roundRect(this.x + 8, this.y + 20 - bobOffset - armSwing, 6, 16, 2);
            ctx.fill();
            
            // === COFFEE CUP (held in front arm) ===
            const cupX = this.x + 38 + coffeeWobble;
            const cupY = this.y + 24 - bobOffset + armSwing * 0.5;
            
            // Front arm holding coffee
            ctx.fillStyle = '#F5D0C5'; // Skin color
            ctx.beginPath();
            ctx.roundRect(this.x + 36, this.y + 20 - bobOffset + armSwing * 0.3, 6, 12, 2);
            ctx.fill();
            
            // Coffee cup body
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.roundRect(cupX, cupY, 10, 14, 2);
            ctx.fill();
            
            // Cup sleeve
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(cupX + 1, cupY + 4, 8, 6);
            
            // Coffee inside
            ctx.fillStyle = '#5D4037';
            ctx.beginPath();
            ctx.ellipse(cupX + 5, cupY + 2, 4, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Steam from coffee
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            for (let i = 0; i < 3; i++) {
                const steamOffset = (Date.now() / 200 + i * 2) % 10;
                const steamX = cupX + 3 + i * 2;
                ctx.beginPath();
                ctx.moveTo(steamX, cupY - steamOffset);
                ctx.quadraticCurveTo(steamX + Math.sin(steamOffset) * 3, cupY - steamOffset - 4, steamX, cupY - steamOffset - 8);
                ctx.stroke();
            }
            
            // === HEAD ===
            // Neck
            ctx.fillStyle = '#F5D0C5';
            ctx.fillRect(this.x + 21, this.y + 12 - bobOffset, 8, 8);
            
            // Head shape
            ctx.fillStyle = '#F5D0C5';
            ctx.beginPath();
            ctx.roundRect(this.x + 14, this.y - 2 - bobOffset, 22, 18, 6);
            ctx.fill();
            
            // Hair
            ctx.fillStyle = '#4A3728';
            ctx.beginPath();
            ctx.roundRect(this.x + 13, this.y - 4 - bobOffset, 24, 10, [6, 6, 0, 0]);
            ctx.fill();
            // Hair side
            ctx.fillRect(this.x + 13, this.y + 2 - bobOffset, 3, 6);
            ctx.fillRect(this.x + 34, this.y + 2 - bobOffset, 3, 6);
            
            // Eyes
            ctx.fillStyle = '#2C3E50';
            ctx.beginPath();
            ctx.arc(this.x + 20, this.y + 6 - bobOffset, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x + 30, this.y + 6 - bobOffset, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Smile
            ctx.strokeStyle = '#C0392B';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(this.x + 25, this.y + 8 - bobOffset, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            ctx.restore();
            
            // Reset alpha after invincibility flash
            ctx.globalAlpha = 1;

            // Coffee splash trail when jumping
            if (this.isJumping && this.velocityY < 0) {
                ctx.save();
                for (let i = 0; i < 4; i++) {
                    ctx.fillStyle = '#8B4513';
                    ctx.globalAlpha = 0.4 - i * 0.1;
                    ctx.beginPath();
                    ctx.arc(
                        cupX + 5 + (Math.random() - 0.5) * 8,
                        cupY + 14 + i * 6 + Math.random() * 4,
                        3 - i * 0.5,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        getBounds() {
            return {
                x: this.x + 5,
                y: this.y + 5,
                width: this.width - 10,
                height: this.height - 10
            };
        }
    }

    class Hazard {
        constructor(type) {
            this.x = CONFIG.CANVAS_WIDTH + 50;
            this.width = 70;  // Increased from 50
            this.height = 70; // Increased from 50
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - this.height;
            this.type = type;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.passed = false; // Track if player successfully jumped over
            this.descriptionShown = false;
            
            // Get hazard metadata
            const meta = VAULT_SOLUTIONS[type] || {};
            this.icon = meta.icon || '‚ö†Ô∏è';
            this.category = meta.category || 'data_loss';
            this.impact = meta.impact || '‚ö†Ô∏è Business risk';
            this.severity = meta.severity || 'medium';
            this.vaultSolution = meta.vaultSolution || 'Vault provides instant recovery';
            this.recoveryTime = meta.recoveryTime || '< 5 min';
            
            // Category-based color
            const catMeta = HAZARD_CATEGORIES[this.category] || HAZARD_CATEGORIES.data_loss;
            this.categoryColor = catMeta.color;
        }

        update() {
            if (!gameState.learningPaused) {
                this.x -= gameState.speed;
            }
            this.pulsePhase += 0.1;
            // Note: hazard.passed tracking is handled in the main update loop
            // to properly detect when player successfully jumps over
        }

        draw(ctx) {
            const theme = gameState.theme;
            const pulse = Math.sin(this.pulsePhase) * 0.12 + 1;
            const rotation = Math.sin(this.pulsePhase * 0.5) * 0.08;
            
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(rotation);
            ctx.scale(pulse, pulse);
            ctx.translate(-this.width/2, -this.height/2);

            // Glow effect with category color
            ctx.shadowColor = this.categoryColor;
            ctx.shadowBlur = 30;

            // Hazard body - larger with category-based gradient
            const hazardGrad = ctx.createRadialGradient(
                this.width/2, this.height/2, 0,
                this.width/2, this.height/2, this.width/2
            );
            hazardGrad.addColorStop(0, '#fff');
            hazardGrad.addColorStop(0.3, this.categoryColor);
            hazardGrad.addColorStop(1, this.categoryColor + '88');
            ctx.fillStyle = hazardGrad;
            
            // Draw shape based on category
            ctx.beginPath();
            if (this.category === 'compliance') {
                // Scale/balance shape for compliance
                this.drawScaleShape(ctx);
            } else if (this.category === 'security') {
                // Broken lock shape for security
                this.drawLockShape(ctx);
            } else if (this.category === 'sync') {
                // Broken sync/arrows shape
                this.drawSyncShape(ctx);
            } else {
                // Broken disk shape for data loss
                this.drawDiskShape(ctx);
            }

            // Icon in center (larger)
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText(this.icon, this.width/2, this.height/2);

            // Electric arcs
            ctx.strokeStyle = this.categoryColor;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2 / 4) + this.pulsePhase;
                ctx.beginPath();
                ctx.moveTo(this.width/2 + Math.cos(angle) * 18, this.height/2 + Math.sin(angle) * 18);
                ctx.lineTo(this.width/2 + Math.cos(angle) * 30, this.height/2 + Math.sin(angle) * 30);
                ctx.stroke();
            }

            ctx.restore();

            // Label below hazard - LARGER with background
            ctx.save();
            const labelText = this.type.toUpperCase();
            ctx.font = 'bold 14px Rajdhani, sans-serif';
            const labelWidth = ctx.measureText(labelText).width + 16;
            const labelX = this.x + this.width/2 - labelWidth/2;
            const labelY = this.y + this.height + 6;
            
            // Label background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(labelX, labelY, labelWidth, 22);
            ctx.strokeStyle = this.categoryColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(labelX, labelY, labelWidth, 22);
            
            // Label text
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = this.categoryColor;
            ctx.shadowBlur = 8;
            ctx.fillText(labelText, this.x + this.width/2, labelY + 11);
            ctx.restore();
            
            // Show description if hazard is close to player - EARLIER now (400px)
            this.drawDescription(ctx);
        }

        drawDescription(ctx) {
            const playerX = gameState.player ? gameState.player.x : 0;
            const distance = this.x - playerX;
            
            // Show description earlier (400px away) and keep showing until 50px
            if (distance < 400 && distance > 50 && HAZARD_DESCRIPTIONS[this.type]) {
                const desc = HAZARD_DESCRIPTIONS[this.type];
                const maxWidth = 300;
                
                ctx.save();
                ctx.font = '13px Rajdhani, sans-serif';
                const lines = wrapText(ctx, desc, maxWidth - 20, '13px Rajdhani, sans-serif');
                
                // Add impact line
                const impactLine = this.impact;
                const boxHeight = (lines.length + 2) * 18 + 20;
                const boxX = Math.min(this.x + this.width/2 - maxWidth/2, CONFIG.CANVAS_WIDTH - maxWidth - 20);
                const boxY = Math.max(70, this.y - boxHeight - 15);
                
                // Description box with gradient background
                const boxGrad = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight);
                boxGrad.addColorStop(0, 'rgba(20, 20, 30, 0.95)');
                boxGrad.addColorStop(1, 'rgba(10, 10, 20, 0.98)');
                ctx.fillStyle = boxGrad;
                ctx.strokeStyle = this.categoryColor;
                ctx.lineWidth = 2;
                
                // Rounded rectangle
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, maxWidth, boxHeight, 8);
                ctx.fill();
                ctx.stroke();
                
                // Header with icon
                ctx.fillStyle = this.categoryColor;
                ctx.font = 'bold 15px Rajdhani, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`${this.icon} ${this.type.toUpperCase()}`, boxX + 12, boxY + 22);
                
                // Impact badge
                ctx.fillStyle = '#FFAA00';
                ctx.font = 'bold 12px Rajdhani, sans-serif';
                ctx.fillText(impactLine, boxX + 12, boxY + 42);
                
                // Separator line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(boxX + 12, boxY + 52);
                ctx.lineTo(boxX + maxWidth - 12, boxY + 52);
                ctx.stroke();
                
                // Description text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '13px Rajdhani, sans-serif';
                ctx.shadowBlur = 0;
                lines.forEach((line, i) => {
                    ctx.fillText(line, boxX + 12, boxY + 72 + i * 18);
                });
                
                ctx.restore();
            }
        }

        // Shape drawing methods for different categories
        drawScaleShape(ctx) {
            // Balance/scale shape for compliance
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner hexagon
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2 / 6) - Math.PI/2;
                const px = cx + Math.cos(angle) * (r * 0.6);
                const py = cy + Math.sin(angle) * (r * 0.6);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        drawLockShape(ctx) {
            // Broken lock shape for security
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Crack effect
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 15);
            ctx.lineTo(cx + 5, cy);
            ctx.lineTo(cx - 8, cy + 12);
            ctx.stroke();
        }

        drawSyncShape(ctx) {
            // Broken sync arrows for sync errors
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Broken circle arrows
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.5, 0, Math.PI * 1.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.5, Math.PI, Math.PI * 2.2);
            ctx.stroke();
        }

        drawDiskShape(ctx) {
            // Broken disk shape for data loss
            const cx = this.width/2, cy = this.height/2;
            const r = this.width/2 - 5;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner broken disk
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Crack
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + r * 0.3, cy - r * 0.3);
            ctx.lineTo(cx - r * 0.3, cy + r * 0.3);
            ctx.stroke();
        }

        isOffScreen() {
            return this.x + this.width < 0;
        }

        getBounds() {
            return { x: this.x + 8, y: this.y + 8, width: this.width - 16, height: this.height - 16 };
        }
    }

    class Orb {
        constructor() {
            this.x = CONFIG.CANVAS_WIDTH + 30;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 80 - Math.random() * 100;
            this.radius = 15;
            this.collected = false;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.type = gameState.theme.collectibles[Math.floor(Math.random() * gameState.theme.collectibles.length)];
        }

        update() {
            this.x -= gameState.speed;
            this.pulsePhase += 0.15;
        }

        draw(ctx) {
            if (this.collected) return;
            
            const theme = gameState.theme;
            const pulse = Math.sin(this.pulsePhase) * 4;
            const bobY = Math.sin(this.pulsePhase * 0.7) * 3;

            ctx.save();
            
            // Outer glow rings
            ctx.shadowColor = theme.colors.accent;
            ctx.shadowBlur = 20;
            
            // Pulsing outer ring
            ctx.strokeStyle = theme.colors.accent + '44';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius + 8 + pulse, 0, Math.PI * 2);
            ctx.stroke();

            // Glow effect
            const gradient = ctx.createRadialGradient(
                this.x, this.y + bobY, 0,
                this.x, this.y + bobY, this.radius + 15 + pulse
            );
            gradient.addColorStop(0, theme.colors.accent);
            gradient.addColorStop(0.4, theme.colors.accent + 'AA');
            gradient.addColorStop(0.7, theme.colors.accent + '44');
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius + 15 + pulse, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Core orb with gradient
            const coreGrad = ctx.createRadialGradient(
                this.x - 4, this.y + bobY - 4, 0,
                this.x, this.y + bobY, this.radius
            );
            coreGrad.addColorStop(0, '#fff');
            coreGrad.addColorStop(0.3, theme.colors.accent);
            coreGrad.addColorStop(1, theme.colors.secondary);
            
            ctx.beginPath();
            ctx.arc(this.x, this.y + bobY, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = coreGrad;
            ctx.fill();

            // Inner sparkle
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.8 + Math.sin(this.pulsePhase * 2) * 0.2;
            ctx.beginPath();
            ctx.arc(this.x - 4, this.y + bobY - 4, 4, 0, Math.PI * 2);
            ctx.fill();

            // Data symbol inside
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚óà', this.x, this.y + bobY + 1);
            
            ctx.restore();
        }

        isOffScreen() {
            return this.x + this.radius < 0;
        }

        getBounds() {
            return { 
                x: this.x - this.radius, 
                y: this.y - this.radius, 
                width: this.radius * 2, 
                height: this.radius * 2 
            };
        }
    }

    class PowerUp {
        constructor() {
            this.x = CONFIG.CANVAS_WIDTH + 30;
            this.y = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 100 - Math.random() * 80;
            this.width = 40;
            this.height = 40;
            this.collected = false;
            this.rotation = 0;
        }

        update() {
            this.x -= gameState.speed;
            this.rotation += 0.05;
        }

        draw(ctx) {
            if (this.collected) return;

            const bobY = Math.sin(Date.now() / 200) * 5;
            const pulse = Math.sin(Date.now() / 150) * 0.1 + 1;

            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2 + bobY);
            ctx.rotate(this.rotation);
            ctx.scale(pulse, pulse);
            ctx.translate(-this.width/2, -this.height/2);

            // Outer glow
            ctx.shadowColor = '#00FFD1';
            ctx.shadowBlur = 30;

            // Shield shape with better proportions
            ctx.beginPath();
            ctx.moveTo(this.width/2, 2);
            ctx.lineTo(this.width - 2, this.height * 0.25);
            ctx.lineTo(this.width - 2, this.height * 0.55);
            ctx.quadraticCurveTo(this.width/2, this.height + 5, 2, this.height * 0.55);
            ctx.lineTo(2, this.height * 0.25);
            ctx.closePath();

            // Shield gradient
            const gradient = ctx.createLinearGradient(0, 0, this.width, this.height);
            gradient.addColorStop(0, '#00FFD1');
            gradient.addColorStop(0.5, '#6C5CE7');
            gradient.addColorStop(1, '#00FFD1');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Inner shield detail
            ctx.beginPath();
            ctx.moveTo(this.width/2, 8);
            ctx.lineTo(this.width - 8, this.height * 0.28);
            ctx.lineTo(this.width - 8, this.height * 0.52);
            ctx.quadraticCurveTo(this.width/2, this.height - 3, 8, this.height * 0.52);
            ctx.lineTo(8, this.height * 0.28);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();

            // VAULT text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('VAULT', this.width/2, this.height/2 + 2);

            // Sparkles around
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 4; i++) {
                const angle = (Date.now() / 500 + i * Math.PI/2);
                const sparkX = this.width/2 + Math.cos(angle) * 28;
                const sparkY = this.height/2 + Math.sin(angle) * 28;
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100 + i) * 0.5;
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        isOffScreen() {
            return this.x + this.width < 0;
        }

        getBounds() {
            return { x: this.x, y: this.y, width: this.width, height: this.height };
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10 - 3;
            this.life = 1;
            this.decay = 0.015 + Math.random() * 0.02;
            this.size = 4 + Math.random() * 6;
            this.color = color;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.3;
            this.type = Math.random() > 0.5 ? 'square' : 'circle';
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.25;
            this.vx *= 0.98;
            this.life -= this.decay;
            this.rotation += this.rotSpeed;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Glow
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = this.color;
            
            if (this.type === 'square') {
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        isDead() {
            return this.life <= 0;
        }
    }

    // Floating text for combo indicators
    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1;
            this.vy = -2;
            this.scale = 0.5;
        }

        update() {
            this.y += this.vy;
            this.vy *= 0.95;
            this.life -= 0.02;
            this.scale = Math.min(this.scale + 0.1, 1.2);
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.font = `bold ${Math.floor(18 * this.scale)}px Orbitron, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Glow effect
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 15;
            
            // Outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            
            // Fill
            ctx.fillStyle = this.color;
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }

        isDead() {
            return this.life <= 0;
        }
    }

    class BackgroundElement {
        constructor(type) {
            this.x = CONFIG.CANVAS_WIDTH;
            this.type = type;
            this.speed = 0.3 + Math.random() * 1.5;
            this.y = 40 + Math.random() * (CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 180);
            this.size = 15 + Math.random() * 35;
            this.alpha = 0.08 + Math.random() * 0.15;
            this.dataString = Math.random() > 0.5 ? '10110' : '01001';
            this.pulsePhase = Math.random() * Math.PI * 2;
        }

        update() {
            this.x -= this.speed;
            this.pulsePhase += 0.02;
        }

        draw(ctx) {
            const theme = gameState.theme;
            ctx.save();
            ctx.globalAlpha = this.alpha;
            
            switch(this.type) {
                case 'cloud':
                    // Data cloud (hexagon cluster)
                    ctx.fillStyle = theme.colors.secondary + '40';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const offsetX = i * this.size * 0.6;
                        const offsetY = (i % 2) * this.size * 0.3;
                        this.drawHexagon(ctx, this.x + offsetX, this.y + offsetY, this.size * 0.4);
                        ctx.fill();
                    }
                    break;
                case 'building':
                    // Server rack
                    ctx.fillStyle = theme.colors.secondary + '30';
                    ctx.fillRect(this.x, this.y, this.size * 0.5, this.size * 2.5);
                    // LEDs
                    const blinkPhase = Math.sin(this.pulsePhase);
                    for (let i = 0; i < 6; i++) {
                        ctx.fillStyle = blinkPhase > (i * 0.3 - 0.9) ? theme.colors.primary + '80' : theme.colors.hazard + '40';
                        ctx.beginPath();
                        ctx.arc(this.x + this.size * 0.25, this.y + 15 + i * 18, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                case 'data':
                    // Floating data stream
                    ctx.fillStyle = theme.colors.primary + '60';
                    ctx.font = `${this.size * 0.6}px monospace`;
                    const floatY = Math.sin(this.pulsePhase) * 5;
                    ctx.fillText(this.dataString, this.x, this.y + floatY);
                    break;
            }
            ctx.restore();
        }

        drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) - Math.PI / 6;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }

        isOffScreen() {
            return this.x + this.size * 2 < 0;
        }
    }

    // ==========================================
    // GAME FUNCTIONS
    // ==========================================
    function initGame() {
        resizeCanvas();
        
        // Apply difficulty settings to CONFIG
        const diff = gameState.difficultySettings;
        CONFIG.INITIAL_SPEED = diff.initialSpeed;
        CONFIG.MAX_SPEED = diff.maxSpeed;
        CONFIG.SPEED_INCREMENT = diff.speedIncrement;
        CONFIG.HAZARD_SPAWN_RATE = diff.hazardSpawnRate;
        CONFIG.ORB_SPAWN_RATE = diff.orbSpawnRate;
        CONFIG.POWERUP_SPAWN_RATE = diff.powerupSpawnRate;
        CONFIG.SHIELD_DURATION = diff.shieldDuration;
        
        gameState.player = new Player();
        gameState.score = 0;
        gameState.survivalScoreAccumulator = 0;
        gameState.speed = CONFIG.INITIAL_SPEED;
        gameState.hazards = [];
        gameState.orbs = [];
        gameState.powerups = [];
        gameState.particles = [];
        gameState.bgElements = [];
        gameState.shieldActive = false;
        gameState.waveTimer = 0;
        gameState.currentWave = null;
        gameState.isRunning = true;
        gameState.isPaused = false;
        gameState.combo = 0;
        gameState.maxCombo = 0;
        gameState.comboTimer = 0;
        gameState.multiplier = 1;
        gameState.distance = 0;
        // Apply difficulty multiplier + streak bonus
        const streakBonusPercent = getStreakBonus(gameState.streak);
        gameState.baseScoreMultiplier = diff.scoreMultiplier * (1 + streakBonusPercent / 100);
        
        // Reset threat tracking
        gameState.threatsAvoided = 0;
        gameState.threatsAvoidedList = [];
        gameState.protectedFlash = null;
        
        // Reset lives system
        resetLives();
        
        // Reset learning mode state
        gameState.learningPaused = false;
        gameState.currentLearningHazard = null;
        if (gameState.learningResumeTimer) {
            clearTimeout(gameState.learningResumeTimer);
            gameState.learningResumeTimer = null;
        }
        
        // Apply learning mode speed modifier
        if (gameState.learningMode) {
            gameState.speed = CONFIG.INITIAL_SPEED * 0.5;
        }

        elements.hudScore.textContent = '0';
        elements.powerUpIndicator.classList.add('hidden');
        elements.pauseOverlay.classList.add('hidden');
        
        // Update difficulty display in HUD
        elements.hudDifficultyIcon.textContent = diff.icon;
        elements.hudDifficultyName.textContent = diff.name;

        trackEvent('game_start', { 
            industry: gameState.userData.industry,
            theme: gameState.theme.name,
            difficulty: gameState.difficulty
        });
    }

    function resizeCanvas() {
        const container = elements.gameContainer;
        const aspectRatio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
        
        let width = container.clientWidth;
        let height = container.clientHeight;
        
        if (width / height > aspectRatio) {
            width = height * aspectRatio;
        } else {
            height = width / aspectRatio;
        }
        
        elements.canvas.width = CONFIG.CANVAS_WIDTH;
        elements.canvas.height = CONFIG.CANVAS_HEIGHT;
        elements.canvas.style.width = `${width}px`;
        elements.canvas.style.height = `${height}px`;
    }

    function spawnHazard() {
        // Check minimum gap between hazards
        const minGap = gameState.difficultySettings.minHazardGap || 250;
        
        // Find the rightmost hazard (most recently spawned, closest to right edge)
        let rightmostHazardX = 0;
        for (const h of gameState.hazards) {
            if (h.x > rightmostHazardX) {
                rightmostHazardX = h.x;
            }
        }
        
        // Only spawn if there's enough gap from the last hazard
        // New hazards spawn at CONFIG.CANVAS_WIDTH + 50
        const newHazardX = CONFIG.CANVAS_WIDTH + 50;
        if (rightmostHazardX > 0 && (newHazardX - rightmostHazardX) < minGap) {
            return; // Don't spawn - too close to last hazard
        }
        
        const theme = gameState.theme;
        const type = theme.hazards[Math.floor(Math.random() * theme.hazards.length)];
        gameState.hazards.push(new Hazard(type));
    }

    function spawnOrb() {
        gameState.orbs.push(new Orb());
    }

    function spawnPowerUp() {
        gameState.powerups.push(new PowerUp());
    }

    function spawnParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            gameState.particles.push(new Particle(x, y, color));
        }
    }

    function spawnBackgroundElement() {
        const types = ['cloud', 'building', 'data'];
        gameState.bgElements.push(new BackgroundElement(types[Math.floor(Math.random() * types.length)]));
    }

    function checkCollision(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }

    function wrapText(ctx, text, maxWidth, font) {
        ctx.font = font;
        const words = text.split(' ');
        const lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
            const word = words[i];
            const width = ctx.measureText(currentLine + ' ' + word).width;
            if (width < maxWidth) {
                currentLine += ' ' + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        }
        lines.push(currentLine);
        return lines;
    }

    function triggerWave() {
        // Skip waves in learning mode to maintain educational pacing
        if (gameState.learningMode) {
            return;
        }
        
        const theme = gameState.theme;
        gameState.currentWave = theme.waves[Math.floor(Math.random() * theme.waves.length)];
        playSound('wave');
        
        // Spawn hazards based on difficulty (fewer in easier modes)
        const waveHazardCount = gameState.difficulty === 'easy' ? 1 : 
                                gameState.difficulty === 'normal' ? 2 : 3;
        const waveDelay = gameState.difficulty === 'easy' ? 1000 : 
                          gameState.difficulty === 'normal' ? 700 : 500;
        
        for (let i = 0; i < waveHazardCount; i++) {
            setTimeout(() => {
                if (gameState.isRunning && !gameState.learningPaused) spawnHazard();
            }, i * waveDelay);
        }
        
        // Clear wave after duration
        setTimeout(() => {
            gameState.currentWave = null;
        }, 3000);
    }

    // Learning mode: check for approaching hazards to trigger educational pause
    function checkLearningModeHazards() {
        if (!gameState.player) return;

        const playerX = gameState.player.x;
        
        for (const hazard of gameState.hazards) {
            // Trigger pause when hazard is 300px away and hasn't been shown yet
            const distance = hazard.x - playerX;
            if (distance > 100 && distance < 300 && !hazard.descriptionShown) {
                hazard.descriptionShown = true;
                gameState.learningPaused = true;
                gameState.currentLearningHazard = hazard;
                
                // Auto-resume after 5 seconds if player doesn't dismiss
                gameState.learningResumeTimer = setTimeout(() => {
                    if (gameState.learningPaused) {
                        gameState.learningPaused = false;
                        gameState.currentLearningHazard = null;
                    }
                }, 5000);
                
                break; // Only pause for one hazard at a time
            }
        }
    }

    // Called when player successfully jumps over a hazard
    function onHazardAvoided(hazard) {
        gameState.threatsAvoided++;
        
        // Store info about avoided threats for end screen
        if (!gameState.threatsAvoidedList.includes(hazard.type)) {
            gameState.threatsAvoidedList.push(hazard.type);
        }
        
        // Trigger protected flash effect
        gameState.protectedFlash = {
            startTime: Date.now(),
            hazardType: hazard.type
        };
        
        // Bonus points for avoiding hazard
        const bonusPoints = Math.floor(25 * (gameState.baseScoreMultiplier || 1));
        gameState.score += bonusPoints;
        elements.hudScore.textContent = gameState.score;
        
        // Spawn celebration particles
        spawnParticles(hazard.x + hazard.width/2, hazard.y, '#00FF88', 12);
        
        trackEvent('hazard_avoided', { 
            hazard_type: hazard.type,
            total_avoided: gameState.threatsAvoided
        });
    }

    function update() {
        if (!gameState.isRunning || gameState.isPaused) return;

        // Update invincibility
        if (gameState.invincible && Date.now() > gameState.invincibleEndTime) {
            gameState.invincible = false;
        }
        
        // Decay screen shake
        if (gameState.screenShake > 0) {
            gameState.screenShake *= 0.9;
            if (gameState.screenShake < 0.5) gameState.screenShake = 0;
        }

        // Learning mode: check for hazards approaching to trigger pause
        if (gameState.learningMode && !gameState.learningPaused) {
            checkLearningModeHazards();
        }

        // If learning mode is paused, only continue rendering but don't update game state
        if (gameState.learningPaused) {
            return;
        }

        // Update player
        gameState.player.update();

        // Increase speed over time (50% slower in learning mode)
        const speedMultiplier = gameState.learningMode ? 0.5 : 1.0;
        const speedIncrement = CONFIG.SPEED_INCREMENT * speedMultiplier;
        const maxSpeed = CONFIG.MAX_SPEED * speedMultiplier;
        gameState.speed = Math.min(gameState.speed + speedIncrement, maxSpeed);

        // Spawn entities (further reduced in learning mode for educational pacing)
        const hazardSpawnRate = gameState.learningMode 
            ? CONFIG.HAZARD_SPAWN_RATE * 0.5  // 50% fewer hazards in learning mode
            : CONFIG.HAZARD_SPAWN_RATE;
        if (Math.random() < hazardSpawnRate) spawnHazard();
        if (Math.random() < CONFIG.ORB_SPAWN_RATE) spawnOrb();
        if (Math.random() < CONFIG.POWERUP_SPAWN_RATE) spawnPowerUp();
        if (Math.random() < 0.005) spawnBackgroundElement();

        // Wave system (less frequent, disabled in learning mode)
        gameState.waveTimer++;
        const waveThreshold = gameState.difficulty === 'easy' ? 1200 : 
                              gameState.difficulty === 'normal' ? 900 : 600;
        const waveProbability = gameState.difficulty === 'easy' ? 0.001 : 
                                gameState.difficulty === 'normal' ? 0.0015 : 0.002;
        if (gameState.waveTimer > waveThreshold && Math.random() < waveProbability) {
            triggerWave();
            gameState.waveTimer = 0;
        }

        // Update shield
        if (gameState.shieldActive && Date.now() > gameState.shieldEndTime) {
            gameState.shieldActive = false;
            elements.powerUpIndicator.classList.add('hidden');
        }

        // Update hazards and check for successful jumps
        gameState.hazards.forEach(h => {
            // Track if hazard was in front of or at player position before update
            const playerLeftEdge = gameState.player.x;
            const hazardRightEdge = h.x + h.width;
            const wasAheadOrAt = hazardRightEdge >= playerLeftEdge;
            
            h.update();
            
            // Check if hazard is now behind player (right edge passed player's left edge)
            const newHazardRightEdge = h.x + h.width;
            const isNowBehind = newHazardRightEdge < playerLeftEdge;
            
            // If hazard moved from ahead/at to behind without being hit, player avoided it
            if (wasAheadOrAt && isNowBehind && !h.passed) {
                h.passed = true;
                onHazardAvoided(h);
            }
        });
        gameState.hazards = gameState.hazards.filter(h => !h.isOffScreen());

        // Update orbs
        gameState.orbs.forEach(o => o.update());
        gameState.orbs = gameState.orbs.filter(o => !o.isOffScreen() && !o.collected);

        // Update powerups
        gameState.powerups.forEach(p => p.update());
        gameState.powerups = gameState.powerups.filter(p => !p.isOffScreen() && !p.collected);

        // Update particles
        gameState.particles.forEach(p => p.update());
        gameState.particles = gameState.particles.filter(p => {
            // Some particles use isDead(), others use isOffScreen()
            if (typeof p.isDead === 'function') return !p.isDead();
            if (typeof p.isOffScreen === 'function') return !p.isOffScreen();
            return true;
        });

        // Update background
        gameState.bgElements.forEach(b => b.update());
        gameState.bgElements = gameState.bgElements.filter(b => !b.isOffScreen());

        // Check collisions
        const playerBounds = gameState.player.getBounds();

        // Hazard collision
        for (const hazard of gameState.hazards) {
            if (checkCollision(playerBounds, hazard.getBounds())) {
                if (gameState.shieldActive) {
                    // Destroy hazard with shield
                    spawnParticles(hazard.x, hazard.y, gameState.theme.colors.hazard, 15);
                    hazard.x = -100; // Move off screen
                } else if (!gameState.invincible) {
                    // Lose a life
                    loseLife(hazard);
                    if (gameState.lives <= 0) {
                        gameOver();
                        return;
                    }
                }
            }
        }

        // Orb collection with combo system
        for (const orb of gameState.orbs) {
            if (!orb.collected && checkCollision(playerBounds, orb.getBounds())) {
                orb.collected = true;
                
                // Combo system
                const now = Date.now();
                if (now - gameState.lastCollectTime < 1500) {
                    gameState.combo++;
                    gameState.multiplier = Math.min(1 + gameState.combo * 0.2, 5); // Max 5x
                } else {
                    gameState.combo = 1;
                    gameState.multiplier = 1;
                }
                gameState.lastCollectTime = now;
                gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                
                const basePoints = 10 * gameState.multiplier;
                const points = Math.floor(basePoints * (gameState.baseScoreMultiplier || 1));
                gameState.score += points;
                elements.hudScore.textContent = gameState.score;
                playSound('collect');
                
                // Enhanced collection effect
                spawnParticles(orb.x, orb.y, gameState.theme.colors.accent, 10 + gameState.combo * 2);
                
                // Add ring burst effect
                gameState.particles.push(new RingBurst(orb.x, orb.y, gameState.theme.colors.accent));
                
                // Show points earned
                gameState.particles.push(new FloatingText(orb.x, orb.y - 10, `+${points}`, '#00FF88'));
                
                // Show combo popup
                if (gameState.combo > 1) {
                    gameState.particles.push(new FloatingText(orb.x, orb.y - 30, `${gameState.combo}x COMBO!`, gameState.theme.colors.secondary));
                }
            }
        }

        // Powerup collection
        for (const powerup of gameState.powerups) {
            if (!powerup.collected && checkCollision(playerBounds, powerup.getBounds())) {
                powerup.collected = true;
                activateShield();
                playSound('powerup');
                spawnParticles(powerup.x, powerup.y, '#00D4AA', 20);
            }
        }

        // Score increment for survival (affected by difficulty multiplier)
        // Use fractional accumulator to avoid always-zero score on Easy mode
        gameState.survivalScoreAccumulator = (gameState.survivalScoreAccumulator || 0) + (gameState.baseScoreMultiplier || 1);
        if (gameState.survivalScoreAccumulator >= 1) {
            const pointsToAdd = Math.floor(gameState.survivalScoreAccumulator);
            gameState.score += pointsToAdd;
            gameState.survivalScoreAccumulator -= pointsToAdd;
        }
        elements.hudScore.textContent = gameState.score;
    }

    function activateShield() {
        gameState.shieldActive = true;
        gameState.shieldEndTime = Date.now() + CONFIG.SHIELD_DURATION;
        elements.powerUpIndicator.classList.remove('hidden');
    }

    function draw() {
        const theme = gameState.theme;
        
        // Apply screen shake
        ctx.save();
        if (gameState.screenShake > 0) {
            const shakeX = (Math.random() - 0.5) * gameState.screenShake * 2;
            const shakeY = (Math.random() - 0.5) * gameState.screenShake * 2;
            ctx.translate(shakeX, shakeY);
        }
        
        // Clear canvas with gradient background
        const bgGradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
        bgGradient.addColorStop(0, '#0F0F23');
        bgGradient.addColorStop(0.4, '#1A1A2E');
        bgGradient.addColorStop(1, '#16213E');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        // Draw city skyline silhouette
        ctx.save();
        const skylineY = CONFIG.CANVAS_HEIGHT * 0.35;
        ctx.fillStyle = 'rgba(22, 33, 62, 0.8)';
        const buildings = [
            { x: 50, w: 40, h: 80 }, { x: 100, w: 30, h: 120 }, { x: 140, w: 50, h: 90 },
            { x: 200, w: 35, h: 140 }, { x: 250, w: 45, h: 70 }, { x: 310, w: 60, h: 110 },
            { x: 380, w: 40, h: 150 }, { x: 430, w: 55, h: 85 }, { x: 500, w: 35, h: 130 },
            { x: 550, w: 50, h: 100 }, { x: 620, w: 40, h: 160 }, { x: 680, w: 55, h: 95 },
            { x: 750, w: 45, h: 125 }, { x: 810, w: 60, h: 80 }, { x: 870, w: 35, h: 110 }
        ];
        buildings.forEach(b => {
            ctx.fillRect(b.x, skylineY - b.h + 50, b.w, b.h);
            // Add window lights
            ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
            for (let wy = skylineY - b.h + 60; wy < skylineY + 40; wy += 15) {
                for (let wx = b.x + 5; wx < b.x + b.w - 5; wx += 12) {
                    if (Math.random() > 0.5) {
                        ctx.fillRect(wx, wy, 6, 8);
                    }
                }
            }
            ctx.fillStyle = 'rgba(22, 33, 62, 0.8)';
        });
        ctx.restore();

        // Draw background elements
        gameState.bgElements.forEach(b => b.draw(ctx));

        // Draw neon grid (perspective)
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 212, 255, 0.15)';
        ctx.lineWidth = 1;
        const gridSpacing = 60;
        const horizon = CONFIG.CANVAS_HEIGHT * 0.3;
        
        // Vertical lines with cyan glow
        for (let x = 0; x < CONFIG.CANVAS_WIDTH; x += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, horizon);
            ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
            ctx.stroke();
        }
        // Horizontal lines with perspective
        for (let y = horizon; y < CONFIG.CANVAS_HEIGHT; y += 30) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(CONFIG.CANVAS_WIDTH, y);
            ctx.stroke();
        }
        ctx.restore();

        // Draw ground with gradient
        const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
        const groundGrad = ctx.createLinearGradient(0, groundY, 0, CONFIG.CANVAS_HEIGHT);
        groundGrad.addColorStop(0, 'rgba(0, 212, 255, 0.1)');
        groundGrad.addColorStop(1, 'rgba(22, 33, 62, 0.8)');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, groundY, CONFIG.CANVAS_WIDTH, CONFIG.GROUND_HEIGHT);

        // Ground line with neon glow
        ctx.save();
        ctx.strokeStyle = '#00D4FF';
        ctx.shadowColor = '#00D4FF';
        ctx.shadowBlur = 10;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, groundY);
        ctx.stroke();
        ctx.restore();

        // Draw running track lines
        ctx.strokeStyle = 'rgba(255, 107, 157, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 40]);
        ctx.beginPath();
        ctx.moveTo(0, groundY + 20);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, groundY + 20);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw speed lines (intensity based on game speed)
        const speedIntensity = Math.min((gameState.speed - 3) / 10, 1);
        if (speedIntensity > 0.1) {
            ctx.save();
            ctx.strokeStyle = `rgba(0, 212, 255, ${speedIntensity * 0.3})`;
            ctx.lineWidth = 2;
            const numLines = Math.floor(speedIntensity * 8) + 2;
            for (let i = 0; i < numLines; i++) {
                const lineY = 80 + (i * 50) + Math.sin(Date.now() / 200 + i) * 20;
                const lineLength = 40 + speedIntensity * 60;
                const lineX = (Date.now() / 3 + i * 100) % (CONFIG.CANVAS_WIDTH + lineLength) - lineLength;
                ctx.beginPath();
                ctx.moveTo(lineX, lineY);
                ctx.lineTo(lineX + lineLength, lineY);
                ctx.stroke();
            }
            ctx.restore();
        }

        // Draw particles
        gameState.particles.forEach(p => p.draw(ctx));

        // Draw powerups
        gameState.powerups.forEach(p => p.draw(ctx));

        // Draw orbs
        gameState.orbs.forEach(o => o.draw(ctx));

        // Draw hazards
        gameState.hazards.forEach(h => h.draw(ctx));

        // Draw player
        gameState.player.draw(ctx);

        // Draw wave warning with animation
        if (gameState.currentWave) {
            ctx.save();
            const waveFlash = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 107, 107, ${waveFlash})`;
            ctx.font = 'bold 22px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#FF6B6B';
            ctx.shadowBlur = 20;
            ctx.fillText(`‚ö†Ô∏è ${gameState.currentWave.toUpperCase()} ‚ö†Ô∏è`, CONFIG.CANVAS_WIDTH / 2, 50);
            ctx.restore();
        }

        // Draw scan line effect (subtle)
        const scanY = (Date.now() / 8) % CONFIG.CANVAS_HEIGHT;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, scanY);
        ctx.lineTo(CONFIG.CANVAS_WIDTH, scanY);
        ctx.stroke();
        ctx.restore();

        // Draw hazard preview lane at top
        drawHazardPreviewLane(ctx);

        // Draw protected flash effect
        if (gameState.protectedFlash) {
            drawProtectedFlash(ctx);
        }

        // Draw learning mode popup if active
        if (gameState.learningMode && gameState.learningPaused && gameState.currentLearningHazard) {
            drawLearningPopup(ctx);
        }

        // Draw mode indicator
        drawModeIndicator(ctx);
        
        // Restore from screen shake
        ctx.restore();
        
        // Draw damage flash overlay (outside of screen shake)
        if (gameState.invincible) {
            const flashAlpha = Math.sin(Date.now() / 50) * 0.15 + 0.1;
            ctx.fillStyle = `rgba(255, 71, 87, ${flashAlpha})`;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }
    }

    function drawHazardPreviewLane(ctx) {
        // Get upcoming hazards (next 3 that haven't passed yet)
        const upcomingHazards = gameState.hazards
            .filter(h => h.x > gameState.player.x + 100)
            .slice(0, 3);

        if (upcomingHazards.length === 0) return;

        ctx.save();

        // Preview lane background
        const laneY = 8;
        const laneHeight = 50;
        const laneWidth = Math.min(upcomingHazards.length * 180 + 140, CONFIG.CANVAS_WIDTH - 40);
        const laneX = CONFIG.CANVAS_WIDTH - laneWidth - 20;

        // Gradient background
        const bgGrad = ctx.createLinearGradient(laneX, laneY, laneX + laneWidth, laneY);
        bgGrad.addColorStop(0, 'rgba(20, 20, 35, 0.9)');
        bgGrad.addColorStop(1, 'rgba(30, 30, 50, 0.95)');
        ctx.fillStyle = bgGrad;
        
        ctx.beginPath();
        ctx.roundRect(laneX, laneY, laneWidth, laneHeight, 8);
        ctx.fill();

        // Border
        ctx.strokeStyle = 'rgba(255, 170, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#FFAA00';
        ctx.font = 'bold 11px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('‚ö†Ô∏è INCOMING:', laneX + 12, laneY + 18);

        // Draw each upcoming hazard preview
        upcomingHazards.forEach((hazard, index) => {
            const previewX = laneX + 100 + index * 170;
            const previewY = laneY + 8;

            // Get category color
            const catMeta = HAZARD_CATEGORIES[hazard.category] || HAZARD_CATEGORIES.data_loss;
            const color = catMeta.color;

            // Mini hazard card
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.roundRect(previewX, previewY, 160, 34, 5);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Icon
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText(hazard.icon, previewX + 18, previewY + 24);

            // Hazard name
            ctx.font = 'bold 11px Rajdhani, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(hazard.type.toUpperCase(), previewX + 36, previewY + 14);

            // Impact preview
            ctx.font = '10px Rajdhani, sans-serif';
            ctx.fillStyle = '#FFAA00';
            ctx.fillText(hazard.impact, previewX + 36, previewY + 28);
        });

        ctx.restore();
    }

    function drawProtectedFlash(ctx) {
        const flash = gameState.protectedFlash;
        const elapsed = Date.now() - flash.startTime;
        const duration = 1500;

        if (elapsed > duration) {
            gameState.protectedFlash = null;
            return;
        }

        const progress = elapsed / duration;
        const alpha = 1 - progress;
        const scale = 1 + progress * 0.5;

        ctx.save();

        // Flash effect on screen
        if (progress < 0.2) {
            ctx.fillStyle = `rgba(0, 255, 136, ${0.3 * (1 - progress * 5)})`;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }

        // "PROTECTED!" text
        ctx.font = `bold ${28 * scale}px Orbitron, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
        ctx.shadowColor = '#00FF88';
        ctx.shadowBlur = 20;
        ctx.fillText('üõ°Ô∏è PROTECTED!', CONFIG.CANVAS_WIDTH / 2, 120);

        // Vault recovery message
        if (flash.hazardType && VAULT_SOLUTIONS[flash.hazardType]) {
            const solution = VAULT_SOLUTIONS[flash.hazardType];
            ctx.font = `${14 * scale}px Rajdhani, sans-serif`;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
            ctx.shadowBlur = 10;
            ctx.fillText(`Vault Recovery: ${solution.recoveryTime}`, CONFIG.CANVAS_WIDTH / 2, 155);
        }

        ctx.restore();
    }

    function drawModeIndicator(ctx) {
        if (!gameState.learningMode) return;

        ctx.save();
        ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
        ctx.font = 'bold 11px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('üìö LEARNING MODE', 15, 25);
        ctx.restore();
    }

    function drawLearningPopup(ctx) {
        const hazard = gameState.currentLearningHazard;
        if (!hazard || !VAULT_SOLUTIONS[hazard.type]) return;

        const solution = VAULT_SOLUTIONS[hazard.type];
        const desc = HAZARD_DESCRIPTIONS[hazard.type] || '';

        ctx.save();

        // Darken background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

        // Popup box
        const popupWidth = 450;
        const popupHeight = 280;
        const popupX = (CONFIG.CANVAS_WIDTH - popupWidth) / 2;
        const popupY = (CONFIG.CANVAS_HEIGHT - popupHeight) / 2 - 30;

        // Gradient background
        const bgGrad = ctx.createLinearGradient(popupX, popupY, popupX, popupY + popupHeight);
        bgGrad.addColorStop(0, 'rgba(20, 25, 40, 0.98)');
        bgGrad.addColorStop(1, 'rgba(10, 15, 30, 0.98)');
        ctx.fillStyle = bgGrad;
        
        ctx.beginPath();
        ctx.roundRect(popupX, popupY, popupWidth, popupHeight, 16);
        ctx.fill();

        // Border with category color
        const catMeta = HAZARD_CATEGORIES[hazard.category] || HAZARD_CATEGORIES.data_loss;
        ctx.strokeStyle = catMeta.color;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Header
        ctx.fillStyle = catMeta.color;
        ctx.font = 'bold 20px Orbitron, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${hazard.icon} ${hazard.type.toUpperCase()}`, CONFIG.CANVAS_WIDTH / 2, popupY + 35);

        // Impact badge
        ctx.fillStyle = '#FFAA00';
        ctx.font = 'bold 14px Rajdhani, sans-serif';
        ctx.fillText(solution.impact, CONFIG.CANVAS_WIDTH / 2, popupY + 60);

        // Separator
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(popupX + 30, popupY + 75);
        ctx.lineTo(popupX + popupWidth - 30, popupY + 75);
        ctx.stroke();

        // Description
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '14px Rajdhani, sans-serif';
        ctx.textAlign = 'left';
        const descLines = wrapText(ctx, desc, popupWidth - 60, '14px Rajdhani, sans-serif');
        descLines.forEach((line, i) => {
            ctx.fillText(line, popupX + 30, popupY + 100 + i * 20);
        });

        // Vault Solution section
        const solutionY = popupY + 100 + descLines.length * 20 + 20;
        
        ctx.fillStyle = '#00FF88';
        ctx.font = 'bold 14px Rajdhani, sans-serif';
        ctx.fillText('üõ°Ô∏è HOW VAULT PROTECTS YOU:', popupX + 30, solutionY);

        ctx.fillStyle = '#FFFFFF';
        ctx.font = '13px Rajdhani, sans-serif';
        const solutionLines = wrapText(ctx, solution.vaultSolution, popupWidth - 60, '13px Rajdhani, sans-serif');
        solutionLines.forEach((line, i) => {
            ctx.fillText(line, popupX + 30, solutionY + 22 + i * 18);
        });

        // Recovery time badge
        ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
        ctx.beginPath();
        ctx.roundRect(popupX + 30, solutionY + 22 + solutionLines.length * 18 + 10, 150, 28, 6);
        ctx.fill();
        ctx.strokeStyle = '#00FF88';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = '#00FF88';
        ctx.font = 'bold 13px Rajdhani, sans-serif';
        ctx.fillText(`‚è±Ô∏è Recovery: ${solution.recoveryTime}`, popupX + 45, solutionY + 22 + solutionLines.length * 18 + 30);

        // Continue instruction
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '12px Rajdhani, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Press SPACE or tap to continue...', CONFIG.CANVAS_WIDTH / 2, popupY + popupHeight - 20);

        ctx.restore();
    }

    function gameLoop() {
        if (!gameState.isPaused) {
            update();
            draw();
        }
        if (gameState.isRunning) {
            requestAnimationFrame(gameLoop);
        } else {
            gameState.loopRunning = false;
        }
    }

    // ==========================================
    // LIVES SYSTEM
    // ==========================================
    function loseLife(hazard) {
        gameState.lives--;
        gameState.invincible = true;
        gameState.invincibleEndTime = Date.now() + 2000; // 2 seconds invincibility
        gameState.screenShake = 15;
        
        // Update hearts display
        updateHeartsDisplay();
        
        // Play hit sound
        playSound('hit');
        
        // Spawn damage particles (coffee splash!)
        const player = gameState.player;
        for (let i = 0; i < 12; i++) {
            gameState.particles.push(new CoffeeSplash(
                player.x + player.width / 2,
                player.y + player.height / 2
            ));
        }
        
        // Show damage text
        gameState.particles.push(new FloatingText(
            player.x + player.width / 2,
            player.y - 20,
            gameState.lives > 0 ? `OUCH! ${gameState.lives} ‚ù§Ô∏è left` : 'NO MORE COFFEE!',
            '#FF4757'
        ));
        
        // Remove the hazard that hit us
        hazard.x = -100;
    }

    function updateHeartsDisplay() {
        const hearts = elements.hudLives.querySelectorAll('.heart');
        hearts.forEach((heart, index) => {
            if (index < gameState.lives) {
                heart.classList.add('active');
                heart.classList.remove('lost');
            } else {
                heart.classList.remove('active');
                heart.classList.add('lost');
                // Trigger damage animation on the heart that was just lost
                if (index === gameState.lives) {
                    heart.classList.add('damage');
                    setTimeout(() => heart.classList.remove('damage'), 500);
                }
            }
        });
    }

    function resetLives() {
        gameState.lives = gameState.maxLives;
        gameState.invincible = false;
        gameState.invincibleEndTime = 0;
        gameState.screenShake = 0;
        
        // Reset hearts display
        const hearts = elements.hudLives.querySelectorAll('.heart');
        hearts.forEach(heart => {
            heart.classList.add('active');
            heart.classList.remove('lost', 'damage');
        });
    }

    // Coffee splash particle class
    class CoffeeSplash {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = Math.random() * -8 - 4;
            this.size = Math.random() * 6 + 3;
            this.life = 1;
            this.gravity = 0.3;
            this.color = Math.random() > 0.3 ? '#8B4513' : '#D2691E'; // Brown coffee colors
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.life -= 0.025;
            this.size *= 0.98;
        }

        draw(ctx) {
            if (this.life <= 0) return;
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        isOffScreen() {
            return this.life <= 0 || this.y > CONFIG.CANVAS_HEIGHT + 50;
        }
    }

    // Ring burst effect for collecting orbs
    class RingBurst {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.radius = 5;
            this.maxRadius = 40;
            this.life = 1;
        }

        update() {
            this.radius += 3;
            this.life = 1 - (this.radius / this.maxRadius);
        }

        draw(ctx) {
            if (this.life <= 0) return;
            ctx.save();
            ctx.globalAlpha = this.life * 0.6;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        isOffScreen() {
            return this.radius >= this.maxRadius;
        }
    }

    function gameOver() {
        gameState.isRunning = false;
        playSound('hit');
        
        // Update streak (save that user played today)
        const streakData = loadStreak();
        if (streakData.isNewDay) {
            gameState.streak = streakData.streak;
            saveStreak(gameState.streak);
        }
        
        const isNewHighScore = saveHighScore(gameState.score);
        gameState.highScore = loadHighScore();
        
        // Save to local leaderboard
        saveToLocalLeaderboard(gameState.score);
        
        // Submit to global leaderboard (async, don't block)
        submitToGlobalLeaderboard(gameState.score);

        trackEvent('game_over', { 
            score: gameState.score,
            industry: gameState.userData.industry,
            difficulty: gameState.difficulty,
            is_high_score: isNewHighScore,
            streak: gameState.streak
        });

        showEndScreen(isNewHighScore);
    }

    // ==========================================
    // SCREEN MANAGEMENT
    // ==========================================
    function showStartScreen() {
        elements.startModal.classList.remove('hidden');
        elements.endModal.classList.add('hidden');
        elements.gameContainer.classList.add('hidden');

        // Load saved industry preference
        const savedUser = loadUserData();
        if (savedUser && savedUser.industry) {
            elements.playerIndustry.value = savedUser.industry;
            gameState.userData.industry = savedUser.industry;
            gameState.theme = THEMES[savedUser.industry] || THEMES.other;
        }

        // Update industry intro based on current theme
        elements.industryIntro.innerHTML = `<strong>${gameState.theme.name}:</strong> ${gameState.theme.greeting}`;
        
        // Hide high score section if player has never scored
        const highScore = loadHighScore();
        elements.highScoreValue.textContent = highScore;
        document.getElementById('high-score-section').style.display = highScore === 0 ? 'none' : 'block';
    }

    function showGameScreen() {
        elements.startModal.classList.add('hidden');
        elements.endModal.classList.add('hidden');
        elements.gameContainer.classList.remove('hidden');

        // Set industry/theme from selector before starting
        const selectedIndustry = elements.playerIndustry.value || 'other';
        gameState.userData.industry = selectedIndustry;
        gameState.theme = THEMES[selectedIndustry] || THEMES.other;

        initGame();
        if (!gameState.loopRunning) {
            gameState.loopRunning = true;
            gameLoop();
        }
    }

    function showEndScreen(isNewHighScore) {
        elements.startModal.classList.add('hidden');
        elements.endModal.classList.remove('hidden');
        elements.gameContainer.classList.add('hidden');

        const diffName = gameState.difficultySettings.name;
        const diffIcon = gameState.difficultySettings.icon;
        const streakBonus = getStreakBonus(gameState.streak);
        const streakText = streakBonus > 0 ? ` üî•+${streakBonus}%` : '';
        elements.endMessage.textContent = `${isNewHighScore ? 'New High Score!' : 'Great run!'} ${diffIcon}${streakText}`;
        elements.finalScore.textContent = gameState.score;

        // Check for badge (Intern / Pro / Expert tiers)
        // Intern: 0-299 (no badge, encouragement message)
        // Pro: 300-699 (badge earned)
        // Expert: 700+ (top badge)
        const badge = gameState.theme.badge;
        let earnedBadge = null;
        let tierMessage = '';
        
        if (gameState.score >= 700) {
            earnedBadge = { 
                name: `üèÜ Expert ${badge.name}`, 
                desc: `Outstanding! You're a data protection master!`,
                tier: 'expert'
            };
            tierMessage = 'üéâ EXPERT TIER ACHIEVED!';
        } else if (gameState.score >= 300) {
            earnedBadge = { 
                name: `‚≠ê Pro ${badge.name}`, 
                desc: `Great job! You know your data threats!`,
                tier: 'pro'
            };
            tierMessage = 'üëè PRO TIER ACHIEVED!';
        }
        // Under 300 = Intern tier, no badge

        if (earnedBadge) {
            elements.badgeSection.classList.remove('hidden');
            elements.badgeTitle.textContent = earnedBadge.name;
            elements.badgeDescription.textContent = earnedBadge.desc;
            
            // Add tier celebration effect
            elements.badgeSection.setAttribute('data-tier', earnedBadge.tier);
        } else {
            // Intern tier - show encouragement instead
            elements.badgeSection.classList.remove('hidden');
            elements.badgeTitle.textContent = 'üìö Intern Level';
            elements.badgeDescription.textContent = `Score 300+ to earn Pro badge! Keep practicing!`;
            elements.badgeSection.setAttribute('data-tier', 'intern');
        }

        // Update threats avoided section
        updateThreatsAvoidedSection();

        // Update leaderboard
        updateLeaderboard('local');

        // Update CTA link (without email if not provided yet)
        const ctaUrl = `https://autorabit.com/vault-free-trial?source=recovery-runner&industry=${encodeURIComponent(gameState.userData.industry)}&score=${gameState.score}&threats_avoided=${gameState.threatsAvoided}`;
        elements.ctaButton.href = ctaUrl;

        // Reset share form state for new game
        resetShareForm();
    }

    function resetShareForm() {
        // Reset the share unlock state
        gameState.shareUnlocked = false;
        
        // Clear the form fields
        elements.playerName.value = '';
        elements.playerEmail.value = '';
        elements.nameError.style.display = 'none';
        elements.emailError.style.display = 'none';
        
        // Show the form, hide success message
        elements.shareInfoSection.style.display = 'block';
        elements.unlockShareBtn.style.display = 'block';
        elements.shareUnlockedMsg.style.display = 'none';
        
        // Disable share buttons
        disableShareButtons();
    }

    function disableShareButtons() {
        elements.shareX.disabled = true;
        elements.shareX.style.opacity = '0.5';
        elements.shareX.style.cursor = 'not-allowed';
        
        elements.shareLinkedIn.disabled = true;
        elements.shareLinkedIn.style.opacity = '0.5';
        elements.shareLinkedIn.style.cursor = 'not-allowed';
        
        elements.emailResults.disabled = true;
        elements.emailResults.style.opacity = '0.5';
        elements.emailResults.style.cursor = 'not-allowed';
        
        elements.emailFriend.disabled = true;
        elements.emailFriend.style.opacity = '0.5';
        elements.emailFriend.style.cursor = 'not-allowed';
    }

    function enableShareButtons() {
        elements.shareX.disabled = false;
        elements.shareX.style.opacity = '1';
        elements.shareX.style.cursor = 'pointer';
        
        elements.shareLinkedIn.disabled = false;
        elements.shareLinkedIn.style.opacity = '1';
        elements.shareLinkedIn.style.cursor = 'pointer';
        
        elements.emailResults.disabled = false;
        elements.emailResults.style.opacity = '1';
        elements.emailResults.style.cursor = 'pointer';
        
        elements.emailFriend.disabled = false;
        elements.emailFriend.style.opacity = '1';
        elements.emailFriend.style.cursor = 'pointer';
    }

    function unlockSharing() {
        let isValid = true;

        // Validate name
        if (!elements.playerName.value.trim()) {
            elements.nameError.style.display = 'block';
            isValid = false;
        } else {
            elements.nameError.style.display = 'none';
        }

        // Validate email
        if (!validateEmail(elements.playerEmail.value)) {
            elements.emailError.style.display = 'block';
            isValid = false;
        } else {
            elements.emailError.style.display = 'none';
        }

        if (!isValid) return;

        // Save user data
        gameState.userData.name = elements.playerName.value.trim();
        gameState.userData.email = elements.playerEmail.value.trim();
        gameState.shareUnlocked = true;

        // Save to localStorage
        saveUserData(gameState.userData);

        // Update leaderboard entry with the user's actual name
        updateRecentLeaderboardEntry(gameState.userData.name);
        
        // Refresh the leaderboard display to show updated name
        updateLeaderboard('local');

        // Update CTA link with email
        const ctaUrl = `https://autorabit.com/vault-free-trial?source=recovery-runner&email=${encodeURIComponent(gameState.userData.email)}&industry=${encodeURIComponent(gameState.userData.industry)}&score=${gameState.score}&threats_avoided=${gameState.threatsAvoided}`;
        elements.ctaButton.href = ctaUrl;

        // Show success and enable sharing
        elements.unlockShareBtn.style.display = 'none';
        elements.shareUnlockedMsg.style.display = 'block';
        enableShareButtons();

        trackEvent('share_unlocked', { 
            score: gameState.score,
            industry: gameState.userData.industry
        });
    }

    // ==========================================
    // LEADERBOARD UI
    // ==========================================
    const INDUSTRY_ICONS = {
        banking: 'üè¶',
        healthcare: 'üè•',
        retail: 'üõí',
        other: '‚òÅÔ∏è'
    };

    function getRankDisplay(rank) {
        if (rank === 1) return 'ü•á';
        if (rank === 2) return 'ü•à';
        if (rank === 3) return 'ü•â';
        return `#${rank}`;
    }

    function formatDate(dateStr) {
        try {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        } catch (e) {
            return '';
        }
    }

    function renderLeaderboardEntries(entries, currentScore) {
        const content = document.getElementById('leaderboard-content');
        if (!content) return;

        if (!entries || entries.length === 0) {
            content.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
            return;
        }

        let html = '';
        entries.forEach((entry, index) => {
            const rank = index + 1;
            const isCurrentGame = entry.score === currentScore && entry.name === (gameState.userData.name || 'Anonymous');
            const industryIcon = INDUSTRY_ICONS[entry.industry] || INDUSTRY_ICONS.other;
            
            html += `
                <div class="leaderboard-entry${isCurrentGame ? ' highlight' : ''}">
                    <div class="leaderboard-rank">${getRankDisplay(rank)}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-name">${escapeHtml(entry.name || 'Anonymous')}</div>
                        <div class="leaderboard-meta">
                            <span>${industryIcon} ${entry.industry || 'other'}</span>
                            <span>${formatDate(entry.date)}</span>
                        </div>
                    </div>
                    <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                </div>
            `;
        });
        content.innerHTML = html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function updateLeaderboard(tab = 'local') {
        const content = document.getElementById('leaderboard-content');
        if (!content) return;

        content.innerHTML = '<div class="leaderboard-loading">Loading...</div>';

        if (tab === 'local') {
            const entries = getLocalLeaderboard();
            renderLeaderboardEntries(entries, gameState.score);
        } else if (tab === 'global') {
            const entries = await fetchGlobalLeaderboard();
            if (entries.length === 0 && firebaseConfig.apiKey === "YOUR_API_KEY") {
                content.innerHTML = '<div class="leaderboard-empty">Global leaderboard not configured.<br><small style="color: var(--text-muted);">Set up Firebase to enable.</small></div>';
            } else {
                renderLeaderboardEntries(entries, gameState.score);
            }
        }
    }

    function setupLeaderboardTabs() {
        const localTab = document.getElementById('tab-local');
        const globalTab = document.getElementById('tab-global');

        if (localTab) {
            localTab.addEventListener('click', () => {
                localTab.classList.add('active');
                if (globalTab) globalTab.classList.remove('active');
                updateLeaderboard('local');
            });
        }

        if (globalTab) {
            globalTab.addEventListener('click', () => {
                globalTab.classList.add('active');
                if (localTab) localTab.classList.remove('active');
                updateLeaderboard('global');
            });
        }
    }

    function updateThreatsAvoidedSection() {
        const section = document.getElementById('threats-avoided-section');
        const countEl = document.getElementById('threats-count');
        const listEl = document.getElementById('threats-list');
        const messageEl = document.getElementById('vault-protection-message');

        if (!section || !countEl || !listEl) return;

        // Update counts
        countEl.textContent = gameState.threatsAvoided;
        const uniqueCountEl = document.getElementById('unique-threats-count');
        if (uniqueCountEl) {
            uniqueCountEl.textContent = gameState.threatsAvoidedList.length;
        }

        // Clear and populate threat cards with learning info
        listEl.innerHTML = '';

        if (gameState.threatsAvoidedList.length === 0) {
            listEl.innerHTML = '<span style="color: var(--text-muted); font-size: 0.85rem;">No threats encountered yet - try again!</span>';
        } else {
            // Create a container for detailed threat cards
            const cardsContainer = document.createElement('div');
            cardsContainer.style.cssText = 'width: 100%; display: flex; flex-direction: column; gap: 12px;';
            
            // Show detailed learning cards for each threat type encountered
            gameState.threatsAvoidedList.forEach(threatType => {
                const solution = VAULT_SOLUTIONS[threatType];
                const description = HAZARD_DESCRIPTIONS[threatType];
                if (solution) {
                    const card = document.createElement('div');
                    card.style.cssText = `
                        background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
                        border: 1px solid rgba(255,255,255,0.15);
                        border-left: 4px solid ${getCategoryColor(solution.category)};
                        border-radius: 10px;
                        padding: 14px 16px;
                        text-align: left;
                    `;
                    card.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <span style="font-size: 1.4rem;">${solution.icon}</span>
                            <span style="font-weight: 600; color: #fff; font-size: 0.95rem;">${threatType}</span>
                            <span style="margin-left: auto; background: rgba(255,107,107,0.2); color: #FF6B6B; padding: 3px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: 600;">${solution.impact}</span>
                        </div>
                        ${description ? `<p style="color: var(--text-muted); font-size: 0.8rem; margin: 0 0 10px 0; line-height: 1.4;">${description}</p>` : ''}
                        <div style="background: rgba(0, 255, 136, 0.1); border-radius: 8px; padding: 10px 12px; display: flex; align-items: flex-start; gap: 10px;">
                            <span style="color: #00FF88; font-size: 1.1rem;">‚úì</span>
                            <div>
                                <p style="color: #00FF88; font-size: 0.85rem; margin: 0 0 4px 0; font-weight: 500;">How Vault Protects You:</p>
                                <p style="color: rgba(255,255,255,0.9); font-size: 0.8rem; margin: 0; line-height: 1.4;">${solution.vaultSolution}</p>
                                <p style="color: #64C8FF; font-size: 0.75rem; margin: 6px 0 0 0; font-weight: 600;">‚ö° Recovery Time: ${solution.recoveryTime}</p>
                            </div>
                        </div>
                    `;
                    cardsContainer.appendChild(card);
                }
            });
            
            listEl.appendChild(cardsContainer);
        }

        // Update protection message based on count
        if (messageEl) {
            if (gameState.threatsAvoided === 0) {
                messageEl.textContent = 'Data disasters can strike at any time. Vault ensures instant recovery.';
            } else if (gameState.threatsAvoided < 5) {
                messageEl.textContent = `You avoided ${gameState.threatsAvoided} threat${gameState.threatsAvoided > 1 ? 's' : ''}! With Vault, recovery takes minutes, not weeks.`;
            } else if (gameState.threatsAvoided < 15) {
                messageEl.textContent = `Impressive! ${gameState.threatsAvoided} threats neutralized. Vault provides this protection 24/7 for your real data.`;
            } else {
                messageEl.textContent = `üèÜ ${gameState.threatsAvoided} threats defeated! You're a data protection champion. Imagine this protection for your Salesforce org.`;
            }
        }
    }

    // Helper to get category color for threat cards
    function getCategoryColor(category) {
        const colors = {
            data_loss: '#FF6B6B',
            compliance: '#FFD93D',
            security: '#FF4757',
            sync: '#FFA502'
        };
        return colors[category] || '#6C5CE7';
    }

    // ==========================================
    // EVENT HANDLERS
    // ==========================================
    
    // Unlock share button handler
    elements.unlockShareBtn.addEventListener('click', () => {
        unlockSharing();
    });

    // Industry selection handler (on start screen)
    elements.playerIndustry.addEventListener('change', () => {
        const selectedIndustry = elements.playerIndustry.value || 'other';
        gameState.userData.industry = selectedIndustry;
        gameState.theme = THEMES[selectedIndustry] || THEMES.other;
        
        // Update industry intro text
        elements.industryIntro.innerHTML = `<strong>${gameState.theme.name}:</strong> ${gameState.theme.greeting}`;
        
        // Save preference
        try {
            const savedUser = loadUserData() || {};
            savedUser.industry = selectedIndustry;
            saveUserData(savedUser);
        } catch (e) {
            console.warn('Could not save industry preference:', e);
        }
        
        trackEvent('industry_selected', { industry: selectedIndustry });
    });

    elements.startGameBtn.addEventListener('click', () => {
        initAudio();
        showGameScreen();
    });

    // Difficulty selection
    elements.difficultyOptions.addEventListener('click', (e) => {
        const option = e.target.closest('.difficulty-option');
        if (!option) return;
        
        // Remove selected class from all options
        elements.difficultyOptions.querySelectorAll('.difficulty-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        
        // Add selected class to clicked option
        option.classList.add('selected');
        
        // Update game state with selected difficulty
        const difficulty = option.dataset.difficulty;
        gameState.difficulty = difficulty;
        gameState.difficultySettings = DIFFICULTY_PRESETS[difficulty];
        
        // Save preference
        try {
            localStorage.setItem('recoveryRunner_difficulty', difficulty);
        } catch (e) {
            console.warn('Could not save difficulty preference:', e);
        }
        
        trackEvent('difficulty_selected', { difficulty: difficulty });
    });

    // Load saved difficulty preference
    function loadDifficultyPreference() {
        try {
            const saved = localStorage.getItem('recoveryRunner_difficulty');
            if (saved && DIFFICULTY_PRESETS[saved]) {
                gameState.difficulty = saved;
                gameState.difficultySettings = DIFFICULTY_PRESETS[saved];
                
                // Update UI
                elements.difficultyOptions.querySelectorAll('.difficulty-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.difficulty === saved);
                });
            }
        } catch (e) {
            console.warn('Could not load difficulty preference:', e);
        }
    }

    // Mode toggle selection (Arcade vs Learning)
    function setupModeToggle() {
        const arcadeBtn = elements.arcadeModeBtn;
        const learningBtn = elements.learningModeBtn;
        const modeDesc = elements.modeDescription;

        if (!arcadeBtn || !learningBtn) return;

        arcadeBtn.addEventListener('click', () => {
            gameState.learningMode = false;
            arcadeBtn.style.borderColor = 'var(--primary)';
            arcadeBtn.style.background = 'rgba(108, 92, 231, 0.2)';
            arcadeBtn.classList.add('selected');
            learningBtn.style.borderColor = 'rgba(255,255,255,0.2)';
            learningBtn.style.background = 'rgba(100, 200, 255, 0.1)';
            learningBtn.classList.remove('selected');
            if (modeDesc) {
                modeDesc.innerHTML = 'üéÆ <strong>Arcade:</strong> Fast-paced action with hazard previews at the top of the screen';
            }
            trackEvent('mode_selected', { mode: 'arcade' });
        });

        learningBtn.addEventListener('click', () => {
            gameState.learningMode = true;
            learningBtn.style.borderColor = '#64C8FF';
            learningBtn.style.background = 'rgba(100, 200, 255, 0.2)';
            learningBtn.classList.add('selected');
            arcadeBtn.style.borderColor = 'rgba(255,255,255,0.2)';
            arcadeBtn.style.background = 'rgba(108, 92, 231, 0.1)';
            arcadeBtn.classList.remove('selected');
            if (modeDesc) {
                modeDesc.innerHTML = 'üìö <strong>Learning:</strong> 50% slower speed with auto-pause to learn about each threat and how Vault protects you';
            }
            trackEvent('mode_selected', { mode: 'learning' });
        });
    }

    // Load saved mode preference
    function loadModePreference() {
        try {
            const saved = localStorage.getItem('recoveryRunner_mode');
            if (saved === 'learning') {
                gameState.learningMode = true;
                if (elements.learningModeBtn) {
                    elements.learningModeBtn.click();
                }
            }
        } catch (e) {
            console.warn('Could not load mode preference:', e);
        }
    }

    elements.playAgainBtn.addEventListener('click', () => {
        showStartScreen();
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        if (!gameState.isRunning) return;

        switch(e.code) {
            case 'Space':
            case 'ArrowUp':
                e.preventDefault();
                // Handle learning mode popup dismissal
                if (gameState.learningPaused && gameState.currentLearningHazard) {
                    resumeFromLearningPause();
                    return;
                }
                if (!gameState.isPaused) {
                    gameState.player.jump();
                }
                break;
            case 'KeyP':
                togglePause();
                break;
            case 'KeyM':
                toggleSound();
                break;
        }
    });

    // Touch controls
    elements.canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Handle learning mode popup dismissal
        if (gameState.learningPaused && gameState.currentLearningHazard) {
            resumeFromLearningPause();
            return;
        }
        if (gameState.isRunning && !gameState.isPaused) {
            gameState.player.jump();
        }
    });

    elements.mobileJump.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Handle learning mode popup dismissal
        if (gameState.learningPaused && gameState.currentLearningHazard) {
            resumeFromLearningPause();
            return;
        }
        if (gameState.isRunning && !gameState.isPaused) {
            gameState.player.jump();
        }
    });

    // Resume from learning mode pause
    function resumeFromLearningPause() {
        gameState.learningPaused = false;
        gameState.currentLearningHazard = null;
        if (gameState.learningResumeTimer) {
            clearTimeout(gameState.learningResumeTimer);
            gameState.learningResumeTimer = null;
        }
    }

    // HUD buttons
    elements.pauseBtn.addEventListener('click', togglePause);
    elements.muteBtn.addEventListener('click', toggleSound);
    elements.resumeBtn.addEventListener('click', togglePause);

    function togglePause() {
        if (!gameState.isRunning) return;
        gameState.isPaused = !gameState.isPaused;
        elements.pauseOverlay.classList.toggle('hidden', !gameState.isPaused);
        // Note: Don't call gameLoop() here - the existing loop continues running
        // and will automatically resume updating when isPaused becomes false
    }

    function toggleSound() {
        gameState.soundEnabled = !gameState.soundEnabled;
        elements.muteBtn.textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
    }

    // Share buttons with viral hooks
    elements.shareX.addEventListener('click', () => {
        const gameUrl = window.location.href;
        const badge = gameState.score >= 1000 ? 'üèÜ ELITE ' : gameState.score >= 500 ? 'üõ°Ô∏è ' : 'üéÆ ';
        const diffText = gameState.difficultySettings.name !== 'Normal' ? ` on ${gameState.difficultySettings.name} mode ${gameState.difficultySettings.icon}` : '';
        const text = `${badge}Just scored ${gameState.score} in Recovery Runner${diffText}!\n\nüî• Can YOU survive Salesforce data disasters?\n\nPlay now: ${gameUrl}\n\n#Salesforce #DataBackup #RecoveryRunner @AutoRABIT`;
        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
        trackEvent('share_x', { score: gameState.score, difficulty: gameState.difficulty });
    });

    elements.shareLinkedIn.addEventListener('click', () => {
        const gameUrl = window.location.href;
        const badge = gameState.score >= 1000 ? 'Elite ' : gameState.score >= 500 ? 'Pro ' : '';
        window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(gameUrl)}`, '_blank');
        trackEvent('share_linkedin', { score: gameState.score });
    });

    elements.emailResults.addEventListener('click', () => {
        const badge = gameState.score >= 1000 ? 'üèÜ LEGENDARY' : gameState.score >= 500 ? 'üõ°Ô∏è PRO' : 'üéÆ';
        const diffInfo = gameState.difficultySettings;
        const subject = `${badge} Recovery Runner Score: ${gameState.score}! (${diffInfo.name} Mode)`;
        const body = `Hey!\n\n` +
            `I just scored ${gameState.score} points in Recovery Runner - an addictive game about surviving Salesforce data disasters!\n\n` +
            `üéÆ My Stats:\n` +
            `‚Ä¢ Score: ${gameState.score}\n` +
            `‚Ä¢ Difficulty: ${diffInfo.icon} ${diffInfo.name} (${diffInfo.scoreMultiplier}√ó multiplier)\n` +
            `‚Ä¢ Theme: ${gameState.theme.name}\n` +
            `‚Ä¢ Badge: ${gameState.theme.badge.icon} ${gameState.theme.badge.name}\n\n` +
            `üïπÔ∏è Play here: ${window.location.href}\n\n` +
            `This game actually teaches you real stuff about data protection. Pretty clever marketing from AutoRABIT!\n\n` +
            `üõ°Ô∏è Want real Salesforce backup? Check out Vault:\n` +
            `https://autorabit.com/vault-free-trial?source=recovery-runner&email=${encodeURIComponent(gameState.userData.email)}&industry=${encodeURIComponent(gameState.userData.industry)}`;
        window.location.href = `mailto:${gameState.userData.email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        trackEvent('email_results', { score: gameState.score, difficulty: gameState.difficulty });
    });

    elements.ctaButton.addEventListener('click', () => {
        trackEvent('cta_click', { 
            score: gameState.score,
            industry: gameState.userData.industry
        });
    });

    // Email to Friend handlers
    elements.emailFriend.addEventListener('click', () => {
        elements.friendModal.classList.remove('hidden');
        elements.friendEmail.value = '';
        elements.friendEmail.focus();
    });

    elements.friendCancel.addEventListener('click', () => {
        elements.friendModal.classList.add('hidden');
    });

    elements.friendSend.addEventListener('click', () => {
        const friendEmail = elements.friendEmail.value.trim();
        if (!validateEmail(friendEmail)) {
            elements.friendEmail.style.borderColor = 'var(--danger)';
            setTimeout(() => {
                elements.friendEmail.style.borderColor = '';
            }, 2000);
            return;
        }

        const subject = `${gameState.userData.name} challenges you to Recovery Runner!`;
        const body = `Hey!\n\n${gameState.userData.name} just scored ${gameState.score} points in Recovery Runner and thinks you can't beat it!\n\n` +
            `üéÆ Play now: ${window.location.href}\n\n` +
            `Recovery Runner is a game that teaches you about Salesforce data risks‚Äîcan you survive the data disasters?\n\n` +
            `Ready to protect your real Salesforce data? Try AutoRABIT Vault:\n` +
            `https://autorabit.com/vault-free-trial?source=recovery-runner-challenge`;
        
        window.location.href = `mailto:${friendEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        elements.friendModal.classList.add('hidden');
        trackEvent('email_friend', { score: gameState.score });
    });

    // Close friend modal on background click
    elements.friendModal.addEventListener('click', (e) => {
        if (e.target === elements.friendModal) {
            elements.friendModal.classList.add('hidden');
        }
    });

    // Window resize
    window.addEventListener('resize', resizeCanvas);

    // ==========================================
    // VIRAL FEATURE HANDLERS
    // ==========================================
    
    // Team code generation
    if (elements.generateTeamCodeBtn) {
        elements.generateTeamCodeBtn.addEventListener('click', () => {
            const newCode = generateTeamCode();
            elements.teamCodeInput.value = newCode;
            saveTeamCode(newCode);
            trackEvent('team_code_generated', { code: newCode });
            
            // Visual feedback
            elements.generateTeamCodeBtn.textContent = '‚úì Created!';
            setTimeout(() => {
                elements.generateTeamCodeBtn.textContent = 'Generate';
            }, 2000);
        });
    }

    // Team code input save
    if (elements.teamCodeInput) {
        elements.teamCodeInput.addEventListener('blur', () => {
            const code = elements.teamCodeInput.value.trim().toUpperCase();
            if (code.length >= 4) {
                saveTeamCode(code);
                trackEvent('team_code_joined', { code: code });
            }
        });
        
        // Load saved team code
        const savedTeamCode = loadTeamCode();
        if (savedTeamCode) {
            elements.teamCodeInput.value = savedTeamCode;
            gameState.teamCode = savedTeamCode;
        }
    }

    // Certificate download
    if (elements.downloadCertificate) {
        elements.downloadCertificate.addEventListener('click', () => {
            const cert = generateCertificateData();
            
            // Create a text-based certificate (could be enhanced to generate image)
            const certificateText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë           üõ°Ô∏è DATA PROTECTION ACHIEVEMENT CERTIFICATE üõ°Ô∏è      ‚ïë
‚ïë                                                              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                              ‚ïë
‚ïë   This certifies that                                        ‚ïë
‚ïë                                                              ‚ïë
‚ïë                    ${cert.name.padEnd(40)}              ‚ïë
‚ïë                                                              ‚ïë
‚ïë   has demonstrated exceptional data protection awareness     ‚ïë
‚ïë   by completing Recovery Runner with outstanding results:    ‚ïë
‚ïë                                                              ‚ïë
‚ïë   ${cert.tierEmoji} Achievement Tier: ${cert.tier.padEnd(35)}    ‚ïë
‚ïë   üéÆ Final Score: ${cert.score.toString().padEnd(38)}    ‚ïë
‚ïë   üõ°Ô∏è Threats Defeated: ${cert.threatsDefeated.toString().padEnd(33)}    ‚ïë
‚ïë   üìö Unique Hazards Mastered: ${cert.uniqueThreats.toString().padEnd(26)}    ‚ïë
‚ïë   üè¢ Industry Focus: ${cert.industry.padEnd(35)}    ‚ïë
‚ïë                                                              ‚ïë
‚ïë   Date: ${cert.date.padEnd(48)}    ‚ïë
‚ïë   Certificate ID: ${cert.certificateId.padEnd(38)}    ‚ïë
‚ïë                                                              ‚ïë
‚ïë   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚ïë
‚ïë                                                              ‚ïë
‚ïë   Powered by AutoRABIT Vault - Enterprise Salesforce         ‚ïë
‚ïë   Backup & Recovery                                          ‚ïë
‚ïë                                                              ‚ïë
‚ïë   üîó autorabit.com/vault-free-trial                          ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`.trim();

            // Download as text file
            const blob = new Blob([certificateText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Recovery-Runner-Certificate-${cert.certificateId}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            trackEvent('certificate_downloaded', { tier: cert.tier, score: cert.score });
            
            // Visual feedback
            elements.downloadCertificate.textContent = '‚úì Downloaded!';
            setTimeout(() => {
                elements.downloadCertificate.textContent = 'üìú Download Certificate';
            }, 2000);
        });
    }

    // Copy challenge link
    if (elements.copyChallengeLink) {
        elements.copyChallengeLink.addEventListener('click', async () => {
            const link = generateShareableLink();
            
            try {
                await navigator.clipboard.writeText(link);
                elements.copyChallengeLink.textContent = '‚úì Copied!';
                trackEvent('challenge_link_copied', { score: gameState.score });
            } catch (e) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = link;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                elements.copyChallengeLink.textContent = '‚úì Copied!';
            }
            
            setTimeout(() => {
                elements.copyChallengeLink.textContent = 'üîó Copy Challenge Link';
            }, 2000);
        });
    }

    // Initialize streak display
    function initializeStreak() {
        const streakData = loadStreak();
        gameState.streak = streakData.streak;
        
        if (gameState.streak > 0) {
            const bonus = getStreakBonus(gameState.streak);
            if (elements.streakSection) {
                elements.streakSection.style.display = 'block';
                elements.streakCount.textContent = gameState.streak;
                elements.streakBonus.textContent = bonus;
            }
        }
    }

    // ==========================================
    // INITIALIZE
    // ==========================================
    detectReferral();
    initializeStreak();
    loadDifficultyPreference();
    setupModeToggle();
    loadModePreference();
    setupLeaderboardTabs();
    showStartScreen();

    </script>
</body>
</html>

